"use strict";(globalThis.webpackChunkhumanoid_robotics_course=globalThis.webpackChunkhumanoid_robotics_course||[]).push([[1593],{6680:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-ros-2-fundamentals/practical-lab","title":"Module 2: Practical Lab - ROS 2 Communication Patterns for Robotics","description":"Lab Overview","source":"@site/docs/module-2-ros-2-fundamentals/practical-lab.md","sourceDirName":"module-2-ros-2-fundamentals","slug":"/module-2-ros-2-fundamentals/practical-lab","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/practical-lab","draft":false,"unlisted":false,"editUrl":"https://github.com/RizSheik/humanoid-robotics-course/edit/main/docs/module-2-ros-2-fundamentals/practical-lab.md","tags":[],"version":"current","frontMatter":{}}');var t=o(4848),i=o(8453);const r={},l="Module 2: Practical Lab - ROS 2 Communication Patterns for Robotics",a={},c=[{value:"Lab Overview",id:"lab-overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Required Software/Tools",id:"required-softwaretools",level:3},{value:"Lab Duration",id:"lab-duration",level:3},{value:"Lab 1: Topic-Based Communication for Sensor Data",id:"lab-1-topic-based-communication-for-sensor-data",level:2},{value:"Objective",id:"objective",level:3},{value:"Setup",id:"setup",level:3},{value:"Implementation Steps",id:"implementation-steps",level:3},{value:"Code Template",id:"code-template",level:3},{value:"Analysis",id:"analysis",level:3},{value:"Lab 2: Service-Based Configuration and Control",id:"lab-2-service-based-configuration-and-control",level:2},{value:"Objective",id:"objective-1",level:3},{value:"Setup",id:"setup-1",level:3},{value:"Implementation Steps",id:"implementation-steps-1",level:3},{value:"Code Template",id:"code-template-1",level:3},{value:"Analysis",id:"analysis-1",level:3},{value:"Lab 3: Action-Based Task Execution",id:"lab-3-action-based-task-execution",level:2},{value:"Objective",id:"objective-2",level:3},{value:"Setup",id:"setup-2",level:3},{value:"Implementation Steps",id:"implementation-steps-2",level:3},{value:"Code Template",id:"code-template-2",level:3},{value:"Analysis",id:"analysis-2",level:3},{value:"Lab 4: Multi-Node Communication Architecture",id:"lab-4-multi-node-communication-architecture",level:2},{value:"Objective",id:"objective-3",level:3},{value:"Setup",id:"setup-3",level:3},{value:"Implementation Steps",id:"implementation-steps-3",level:3},{value:"Architecture Design",id:"architecture-design",level:3},{value:"Code Template",id:"code-template-3",level:3},{value:"Analysis",id:"analysis-3",level:3},{value:"Lab Report Requirements",id:"lab-report-requirements",level:2},{value:"Assessment Criteria",id:"assessment-criteria",level:2},{value:"Troubleshooting Tips",id:"troubleshooting-tips",level:2},{value:"Extensions and Advanced Challenges",id:"extensions-and-advanced-challenges",level:2},{value:"References and Further Reading",id:"references-and-further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"module-2-practical-lab---ros-2-communication-patterns-for-robotics",children:"Module 2: Practical Lab - ROS 2 Communication Patterns for Robotics"})}),"\n",(0,t.jsx)(n.h2,{id:"lab-overview",children:"Lab Overview"}),"\n",(0,t.jsx)(n.p,{children:"This practical lab provides hands-on experience with ROS 2 communication patterns in a simulated humanoid robotics environment. Students will implement nodes using different communication patterns (topics, services, and actions) to coordinate robot subsystems, focusing on the specific needs of humanoid robots."}),"\n",(0,t.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"After completing this lab, students will be able to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create and configure ROS 2 nodes using topics for asynchronous communication"}),"\n",(0,t.jsx)(n.li,{children:"Implement service servers and clients for synchronous operations"}),"\n",(0,t.jsx)(n.li,{children:"Develop action servers and clients for long-running tasks"}),"\n",(0,t.jsx)(n.li,{children:"Debug and optimize ROS 2 communication in simulated environments"}),"\n",(0,t.jsx)(n.li,{children:"Design communication architectures for complex robotic systems"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"required-softwaretools",children:"Required Software/Tools"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ROS 2 Humble Hawksbill or later"}),"\n",(0,t.jsx)(n.li,{children:"Gazebo Harmonic or Isaac Sim"}),"\n",(0,t.jsx)(n.li,{children:"Python 3.11+ or C++17"}),"\n",(0,t.jsx)(n.li,{children:"Basic understanding of robotics kinematics and control"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"lab-duration",children:"Lab Duration"}),"\n",(0,t.jsx)(n.p,{children:"This lab is designed for 15-18 hours of work, typically spread over 3 weeks."}),"\n",(0,t.jsx)(n.h2,{id:"lab-1-topic-based-communication-for-sensor-data",children:"Lab 1: Topic-Based Communication for Sensor Data"}),"\n",(0,t.jsx)(n.h3,{id:"objective",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Implement a publisher-subscriber system for sharing sensor data from multiple sensors on a humanoid robot simulation."}),"\n",(0,t.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Launch a humanoid robot model in Gazebo with multiple sensors:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Joint position sensors"}),"\n",(0,t.jsx)(n.li,{children:"IMU (Inertial Measurement Unit)"}),"\n",(0,t.jsx)(n.li,{children:"Camera feeds"}),"\n",(0,t.jsx)(n.li,{children:"Force/torque sensors"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create a sensor fusion node that subscribes to multiple sensor topics"}),"\n",(0,t.jsx)(n.li,{children:"Implement appropriate QoS settings for different sensor types"}),"\n",(0,t.jsx)(n.li,{children:"Publish combined sensor data with proper timestamps and frame IDs"}),"\n",(0,t.jsx)(n.li,{children:"Visualize sensor data using RViz2"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"code-template",children:"Code Template"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu, Image, WrenchStamped\nfrom geometry_msgs.msg import PoseStamped\nfrom std_msgs.msg import Header\nimport numpy as np\nfrom message_filters import ApproximateTimeSync, Subscriber\n\nclass SensorFusionNode(Node):\n    def __init__(self):\n        super().__init__(\'sensor_fusion_node\')\n        \n        # Set up QoS profiles for different sensors\n        # High-frequency sensors: Joint states, IMU\n        sensor_qos = rclpy.qos.QoSProfile(\n            depth=5,\n            reliability=rclpy.qos.ReliabilityPolicy.BEST_EFFORT,\n            durability=rclpy.qos.DurabilityPolicy.VOLATILE\n        )\n        \n        # Lower frequency sensors: Images\n        image_qos = rclpy.qos.QoSProfile(\n            depth=1,\n            reliability=rclpy.qos.ReliabilityPolicy.RELIABLE,\n            durability=rclpy.qos.DurabilityPolicy.VOLATILE\n        )\n        \n        # Create subscribers for different sensor types\n        self.joint_sub = self.create_subscription(\n            JointState, \'joint_states\', self.joint_callback, sensor_qos)\n        \n        self.imu_sub = self.create_subscription(\n            Imu, \'imu/data\', self.imu_callback, sensor_qos)\n        \n        self.force_sub = self.create_subscription(\n            WrenchStamped, \'left_foot/force_torque\', self.force_callback, sensor_qos)\n        \n        # Publisher for fused sensor data\n        self.fused_pub = self.create_publisher(PoseStamped, \'robot_pose\', 10)\n        \n        # Store sensor data\n        self.joint_positions = {}\n        self.imu_data = None\n        self.force_data = None\n        \n        # Timer for sensor fusion\n        self.fusion_timer = self.create_timer(0.01, self.fusion_callback)  # 100Hz\n\n    def joint_callback(self, msg):\n        """Process joint state messages."""\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.joint_positions[name] = msg.position[i]\n        self.get_logger().debug(f\'Updated joint positions for {len(msg.name)} joints\')\n\n    def imu_callback(self, msg):\n        """Process IMU messages."""\n        self.imu_data = msg\n        self.get_logger().debug(\'Updated IMU data\')\n\n    def force_callback(self, msg):\n        """Process force/torque messages."""\n        self.force_data = msg\n        self.get_logger().debug(\'Updated force/torque data\')\n\n    def fusion_callback(self):\n        """Perform sensor fusion to estimate robot pose."""\n        if self.imu_data is not None:\n            # Create a PoseStamped message based on sensor fusion\n            pose_msg = PoseStamped()\n            pose_msg.header = Header()\n            pose_msg.header.stamp = self.get_clock().now().to_msg()\n            pose_msg.header.frame_id = \'odom\'\n            \n            # For simplicity, use orientation from IMU and set position to origin\n            # In a real implementation, this would integrate multiple sensors\n            pose_msg.pose.orientation = self.imu_data.orientation\n            \n            # Publish fused data\n            self.fused_pub.publish(pose_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    sensor_fusion_node = SensorFusionNode()\n    \n    try:\n        rclpy.spin(sensor_fusion_node)\n    except KeyboardInterrupt:\n        sensor_fusion_node.get_logger().info(\'Interrupted by user\')\n    finally:\n        sensor_fusion_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"analysis",children:"Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Monitor data rates and latencies for different sensor types"}),"\n",(0,t.jsx)(n.li,{children:"Evaluate the impact of QoS settings on communication reliability"}),"\n",(0,t.jsx)(n.li,{children:"Analyze the computational overhead of the fusion process"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"lab-2-service-based-configuration-and-control",children:"Lab 2: Service-Based Configuration and Control"}),"\n",(0,t.jsx)(n.h3,{id:"objective-1",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Implement a service-based system for configuring and controlling humanoid robot parameters, such as joint limits, PID gains, or operational modes."}),"\n",(0,t.jsx)(n.h3,{id:"setup-1",children:"Setup"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Use the same humanoid robot simulation from Lab 1"}),"\n",(0,t.jsx)(n.li,{children:"Create a configuration service that allows changing robot parameters"}),"\n",(0,t.jsx)(n.li,{children:"Implement an emergency stop service"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-steps-1",children:"Implementation Steps"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Define custom service messages for robot configuration"}),"\n",(0,t.jsx)(n.li,{children:"Create a service server that handles configuration requests"}),"\n",(0,t.jsx)(n.li,{children:"Implement a service client for configuration changes"}),"\n",(0,t.jsx)(n.li,{children:"Add an emergency stop service with appropriate safety measures"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"code-template-1",children:"Code Template"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom std_srvs.srv import Trigger, SetBool\nfrom sensor_msgs.msg import JointState\nfrom control_msgs.srv import JointTrajectoryControllerState\n\nclass RobotConfigurationService(Node):\n    def __init__(self):\n        super().__init__(\'robot_configuration_service\')\n        \n        # Service for joint limit configuration\n        self.joint_limit_service = self.create_service(\n            JointTrajectoryControllerState,  # Using this as an example\n            \'set_joint_limits\',\n            self.set_joint_limits_callback)\n        \n        # Emergency stop service\n        self.emergency_stop_service = self.create_service(\n            Trigger,\n            \'emergency_stop\',\n            self.emergency_stop_callback)\n        \n        # Mode change service\n        self.mode_change_service = self.create_service(\n            SetBool,\n            \'set_robot_mode\',\n            self.set_robot_mode_callback)\n        \n        # Robot state publisher\n        self.joint_pub = self.create_publisher(JointState, \'joint_commands\', 10)\n        \n        # Current robot state\n        self.current_mode = "idle"  # idle, active, error\n        self.emergency_stopped = False\n        \n        # Define joint limits\n        self.joint_limits = {\n            \'hip_joint\': (-1.57, 1.57),  # min, max in radians\n            \'knee_joint\': (0, 2.5),\n            \'ankle_joint\': (-0.78, 0.78)\n        }\n\n    def set_joint_limits_callback(self, request, response):\n        """Handle joint limit configuration requests."""\n        try:\n            # Validate request\n            if not self.validate_limits_request(request):\n                response.success = False\n                response.error_string = "Invalid joint limit request"\n                return response\n            \n            # Update joint limits\n            self.joint_limits.update(request.joint_names)\n            self.get_logger().info(f\'Updated joint limits: {self.joint_limits}\')\n            \n            response.success = True\n            response.error_string = "Joint limits updated successfully"\n            \n        except Exception as e:\n            self.get_logger().error(f\'Error setting joint limits: {str(e)}\')\n            response.success = False\n            response.error_string = f\'Error: {str(e)}\'\n        \n        return response\n\n    def validate_limits_request(self, request):\n        """Validate joint limit request."""\n        # In a real implementation, this would validate:\n        # - All joint names are valid\n        # - Limits are within physical constraints\n        # - No conflicting constraints\n        return True\n\n    def emergency_stop_callback(self, request, response):\n        """Handle emergency stop requests."""\n        if self.emergency_stopped:\n            response.success = True\n            response.message = "Robot already in emergency stop"\n            return response\n        \n        try:\n            # Execute emergency stop procedure\n            self.execute_emergency_stop()\n            \n            response.success = True\n            response.message = "Emergency stop executed successfully"\n            self.get_logger().warn("EMERGENCY STOP ACTIVATED")\n            \n        except Exception as e:\n            self.get_logger().error(f\'Error during emergency stop: {str(e)}\')\n            response.success = False\n            response.message = f\'Emergency stop failed: {str(e)}\'\n        \n        return response\n\n    def execute_emergency_stop(self):\n        """Execute the actual emergency stop procedure."""\n        # Stop all joint movements\n        stop_msg = JointState()\n        stop_msg.name = list(self.joint_limits.keys())\n        stop_msg.position = [0.0] * len(stop_msg.name)  # Stop at current position\n        self.joint_pub.publish(stop_msg)\n        \n        self.emergency_stopped = True\n        self.current_mode = "error"\n\n    def set_robot_mode_callback(self, request, response):\n        """Handle robot mode change requests."""\n        new_mode = "active" if request.data else "idle"\n        \n        # Validate mode change\n        if self.emergency_stopped and new_mode == "active":\n            response.success = False\n            response.message = "Cannot activate robot in emergency stop state"\n            return response\n        \n        # Execute mode change\n        self.current_mode = new_mode\n        response.success = True\n        response.message = f"Robot mode changed to {new_mode}"\n        \n        self.get_logger().info(f\'Robot mode changed to: {new_mode}\')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    config_service = RobotConfigurationService()\n    \n    try:\n        rclpy.spin(config_service)\n    except KeyboardInterrupt:\n        config_service.get_logger().info(\'Interrupted by user\')\n    finally:\n        config_service.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"analysis-1",children:"Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Measure service response times for different operations"}),"\n",(0,t.jsx)(n.li,{children:"Evaluate the reliability of service-based communication"}),"\n",(0,t.jsx)(n.li,{children:"Test error handling and recovery mechanisms"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"lab-3-action-based-task-execution",children:"Lab 3: Action-Based Task Execution"}),"\n",(0,t.jsx)(n.h3,{id:"objective-2",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Implement action-based communication for long-running humanoid robot tasks such as walking, manipulation, or complex motion patterns."}),"\n",(0,t.jsx)(n.h3,{id:"setup-2",children:"Setup"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create a humanoid robot simulation capable of walking or manipulation"}),"\n",(0,t.jsx)(n.li,{children:"Design an action interface for commanding complex tasks"}),"\n",(0,t.jsx)(n.li,{children:"Implement both action server and client"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-steps-2",children:"Implementation Steps"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Define an action interface for humanoid motion tasks"}),"\n",(0,t.jsx)(n.li,{children:"Implement an action server that executes motions with feedback"}),"\n",(0,t.jsx)(n.li,{children:"Create an action client that sends motion commands and monitors progress"}),"\n",(0,t.jsx)(n.li,{children:"Handle cancellation and preemption of ongoing tasks"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"code-template-2",children:"Code Template"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport time\nimport rclpy\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\n\nclass HumanoidMotionActionServer(Node):\n    def __init__(self):\n        super().__init__('humanoid_motion_action_server')\n        \n        # Create action server\n        self._action_server = ActionServer(\n            self,\n            FollowJointTrajectory,\n            'humanoid_controller/follow_joint_trajectory',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback)\n        \n        # Robot state publisher\n        self.joint_pub = self.create_publisher(\n            JointTrajectoryPoint, 'simulated_joint_commands', 10)\n        \n        # Balance control publisher\n        self.balance_pub = self.create_publisher(\n            JointTrajectoryPoint, 'balance_control_commands', 10)\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject goal requests.\"\"\"\n        # Validate trajectory\n        trajectory = goal_request.trajectory\n        \n        if len(trajectory.points) == 0:\n            self.get_logger().warn('Goal rejected: No trajectory points')\n            return GoalResponse.REJECT\n        \n        # Check if trajectory joints match robot's joints\n        required_joints = set(trajectory.joint_names)\n        robot_joints = set(self.get_robot_joint_names())\n        \n        if not required_joints.issubset(robot_joints):\n            self.get_logger().warn(f'Goal rejected: Unknown joints: {required_joints - robot_joints}')\n            return GoalResponse.REJECT\n        \n        self.get_logger().info('Goal accepted')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Accept cancellation requests.\"\"\"\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute the motion goal.\"\"\"\n        self.get_logger().info('Executing motion goal')\n        \n        # Initialize feedback\n        feedback_msg = FollowJointTrajectory.Feedback()\n        feedback_msg.joint_names = goal_handle.request.trajectory.joint_names\n        result_msg = FollowJointTrajectory.Result()\n        \n        # Get trajectory from goal\n        trajectory = goal_handle.request.trajectory\n        joint_names = trajectory.joint_names\n        points = trajectory.points\n        \n        # Start balance control for humanoid walking\n        self.start_balance_control()\n        \n        try:\n            # Execute trajectory point by point\n            for i, point in enumerate(points):\n                # Check for cancellation\n                if goal_handle.is_cancel_requested:\n                    self.get_logger().info('Motion execution canceled')\n                    result_msg.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n                    goal_handle.canceled()\n                    return result_msg\n                \n                # Update feedback\n                feedback_msg.actual.positions = [0.0] * len(joint_names)\n                feedback_msg.desired = point\n                feedback_msg.error.positions = [0.0] * len(joint_names)\n                \n                # Calculate progress percentage\n                progress = (i + 1) / len(points) * 100.0\n                feedback_msg.progress = progress\n                \n                # Publish feedback\n                goal_handle.publish_feedback(feedback_msg)\n                \n                # Execute the motion\n                self.execute_trajectory_point(point, joint_names)\n                \n                # Log progress\n                self.get_logger().info(f'Progress: {progress:.1f}% ({i+1}/{len(points)})')\n                \n                # Small delay to simulate movement\n                time.sleep(0.1)\n        finally:\n            # Stop balance control regardless of outcome\n            self.stop_balance_control()\n        \n        # Check for final cancellation\n        if goal_handle.is_cancel_requested:\n            result_msg.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n            goal_handle.canceled()\n            return result_msg\n        \n        # Set result and succeed\n        result_msg.error_code = FollowJointTrajectory.Result.SUCCESSFUL\n        goal_handle.succeed()\n        self.get_logger().info('Motion execution completed successfully')\n        \n        return result_msg\n\n    def execute_trajectory_point(self, point, joint_names):\n        \"\"\"Execute a single trajectory point.\"\"\"\n        # Publish joint commands to simulation\n        cmd_msg = JointTrajectoryPoint()\n        cmd_msg.positions = point.positions\n        cmd_msg.velocities = point.velocities if point.velocities else [0.0] * len(point.positions)\n        cmd_msg.accelerations = point.accelerations if point.accelerations else [0.0] * len(point.positions)\n        \n        # Add timestamp\n        cmd_msg.time_from_start = Duration(sec=0, nanosec=100000000)  # 100ms\n        \n        self.joint_pub.publish(cmd_msg)\n        \n        # In a real implementation, this would interface with the robot controller\n        # and potentially adjust based on sensor feedback\n\n    def start_balance_control(self):\n        \"\"\"Start balance control for humanoid motion.\"\"\"\n        # In a real robot, this would start the balance controller\n        self.get_logger().info(\"Balance control started\")\n\n    def stop_balance_control(self):\n        \"\"\"Stop balance control after motion.\"\"\"\n        # In a real robot, this would stop the balance controller\n        self.get_logger().info(\"Balance control stopped\")\n\n    def get_robot_joint_names(self):\n        \"\"\"Get the joint names of the simulated robot.\"\"\"\n        # Define the joints for our simulated humanoid\n        return [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\n            'left_shoulder_joint', 'left_elbow_joint',\n            'right_shoulder_joint', 'right_elbow_joint'\n        ]\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_server = HumanoidMotionActionServer()\n    \n    try:\n        rclpy.spin(action_server)\n    except KeyboardInterrupt:\n        action_server.get_logger().info('Interrupted by user')\n    finally:\n        action_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"analysis-2",children:"Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Evaluate action execution performance under different conditions"}),"\n",(0,t.jsx)(n.li,{children:"Test preemption and cancellation functionality"}),"\n",(0,t.jsx)(n.li,{children:"Analyze feedback mechanisms and their effectiveness"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"lab-4-multi-node-communication-architecture",children:"Lab 4: Multi-Node Communication Architecture"}),"\n",(0,t.jsx)(n.h3,{id:"objective-3",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Design and implement a complete communication architecture for a humanoid robot system with multiple autonomous nodes."}),"\n",(0,t.jsx)(n.h3,{id:"setup-3",children:"Setup"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Create multiple nodes representing different robot subsystems:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Perception node"}),"\n",(0,t.jsx)(n.li,{children:"Planning node"}),"\n",(0,t.jsx)(n.li,{children:"Control node"}),"\n",(0,t.jsx)(n.li,{children:"State estimation node"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Connect them using appropriate ROS 2 communication patterns"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-steps-3",children:"Implementation Steps"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Design a communication architecture for the robot system"}),"\n",(0,t.jsx)(n.li,{children:"Implement each subsystem as a separate node"}),"\n",(0,t.jsx)(n.li,{children:"Connect the nodes using topics, services, and actions"}),"\n",(0,t.jsx)(n.li,{children:"Test the integrated system with simulation scenarios"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"architecture-design",children:"Architecture Design"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Perception Node \u2192 Topic: sensor_data \u2192 State Estimation Node\nPlanning Node \u2192 Action: motion_plan \u2192 Control Node\nHigh-level Controller \u2192 Service: execute_behavior \u2192 Planning Node\n"})}),"\n",(0,t.jsx)(n.h3,{id:"code-template-3",children:"Code Template"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\n# This file contains the high-level architecture node that coordinates\n# the other subsystems\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import PoseStamped\nfrom sensor_msgs.msg import JointState\nfrom std_srvs.srv import Trigger\nfrom rclpy.action import ActionClient\nfrom control_msgs.action import FollowJointTrajectory\n\nclass HumanoidRobotController(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_robot_controller\')\n        \n        # Publishers for commanding other nodes\n        self.state_pub = self.create_publisher(String, \'robot_state\', 10)\n        self.goal_pub = self.create_publisher(PoseStamped, \'navigation_goal\', 10)\n        \n        # Subscribers for monitoring system state\n        self.joint_sub = self.create_subscription(\n            JointState, \'joint_states\', self.joint_state_callback, 10)\n        self.pose_sub = self.create_subscription(\n            PoseStamped, \'robot_pose\', self.pose_callback, 10)\n        \n        # Service client for emergency stop\n        self.emergency_stop_client = self.create_client(\n            Trigger, \'emergency_stop\')\n        \n        # Action client for motion execution\n        self.motion_action_client = ActionClient(\n            self, FollowJointTrajectory, \'humanoid_controller/follow_joint_trajectory\')\n        \n        # Timer for main control loop\n        self.control_timer = self.create_timer(1.0, self.main_control_loop)\n        \n        # Robot state\n        self.current_state = "idle"\n        self.current_pose = None\n        self.joint_states = None\n\n    def joint_state_callback(self, msg):\n        """Update joint states."""\n        self.joint_states = msg\n\n    def pose_callback(self, msg):\n        """Update robot pose."""\n        self.current_pose = msg\n\n    def main_control_loop(self):\n        """Main control loop for the robot."""\n        # Update robot state based on sensors and internal state\n        if self.joint_states is not None and self.current_pose is not None:\n            self.current_state = "active"\n            self.state_pub.publish(String(data=self.current_state))\n            \n            # Example: if robot is idle and a goal is available, plan a motion\n            if self.current_state == "idle":\n                self.plan_and_execute_motion()\n        else:\n            self.current_state = "waiting_for_sensors"\n            self.state_pub.publish(String(data=self.current_state))\n\n    def plan_and_execute_motion(self):\n        """Plan and execute a motion."""\n        # This would call the planning service in a real implementation\n        self.get_logger().info(\'Planning motion...\')\n        \n        # Check if motion action server is available\n        if not self.motion_action_client.wait_for_server(timeout_sec=1.0):\n            self.get_logger().error(\'Motion action server not available\')\n            return\n\n        # Create motion goal\n        goal_msg = FollowJointTrajectory.Goal()\n        # In a real system, this would be populated with a planned trajectory\n        # For simulation, we\'ll use a simple example\n        \n        # Send the goal\n        future = self.motion_action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.motion_feedback_callback)\n        \n        future.add_done_callback(self.motion_goal_response_callback)\n\n    def motion_goal_response_callback(self, future):\n        """Handle motion goal response."""\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Motion goal rejected\')\n            return\n\n        self.get_logger().info(\'Motion goal accepted\')\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.motion_result_callback)\n\n    def motion_feedback_callback(self, feedback_msg):\n        """Handle motion feedback."""\n        feedback = feedback_msg.feedback\n        # Process feedback from motion execution\n        self.get_logger().info(f\'Motion progress: {feedback.progress}%\')\n\n    def motion_result_callback(self, future):\n        """Handle motion result."""\n        result = future.result().result\n        self.get_logger().info(f\'Motion completed with result: {result.error_code}\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    robot_controller = HumanoidRobotController()\n    \n    try:\n        rclpy.spin(robot_controller)\n    except KeyboardInterrupt:\n        robot_controller.get_logger().info(\'Interrupted by user\')\n    finally:\n        robot_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"analysis-3",children:"Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Evaluate the overall system performance and responsiveness"}),"\n",(0,t.jsx)(n.li,{children:"Analyze communication bottlenecks and potential improvements"}),"\n",(0,t.jsx)(n.li,{children:"Test the system's ability to handle multiple concurrent operations"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"lab-report-requirements",children:"Lab Report Requirements"}),"\n",(0,t.jsx)(n.p,{children:"For each lab exercise, students must submit:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implementation Documentation"})," (25%):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Code with proper documentation"}),"\n",(0,t.jsx)(n.li,{children:"Explanation of design decisions"}),"\n",(0,t.jsx)(n.li,{children:"Description of QoS settings and communication pattern choices"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Performance Analysis"})," (40%):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Measurements of latency, throughput, and reliability"}),"\n",(0,t.jsx)(n.li,{children:"Analysis of resource utilization"}),"\n",(0,t.jsx)(n.li,{children:"Comparison of different QoS configurations"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"System Integration Report"})," (25%):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"How different communication patterns work together"}),"\n",(0,t.jsx)(n.li,{children:"Challenges encountered and solutions"}),"\n",(0,t.jsx)(n.li,{children:"Recommendations for improvements"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reflection and Learning"})," (10%):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"What was learned about ROS 2 communication"}),"\n",(0,t.jsx)(n.li,{children:"How concepts apply to real-world robotics"}),"\n",(0,t.jsx)(n.li,{children:"Future directions for improvement"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"assessment-criteria",children:"Assessment Criteria"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Implementation quality and correctness (40%)"}),"\n",(0,t.jsx)(n.li,{children:"Understanding of ROS 2 communication patterns (30%)"}),"\n",(0,t.jsx)(n.li,{children:"Performance analysis and optimization (20%)"}),"\n",(0,t.jsx)(n.li,{children:"Documentation and code quality (10%)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"troubleshooting-tips",children:"Troubleshooting Tips"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topic Connection Issues"}),": Use ",(0,t.jsx)(n.code,{children:"ros2 topic list"})," and ",(0,t.jsx)(n.code,{children:"ros2 node info"})," to verify connections"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"QoS Mismatch"}),": Ensure publishers and subscribers have compatible QoS settings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance Issues"}),": Monitor CPU and memory usage with ",(0,t.jsx)(n.code,{children:"ros2 topic hz"})," and system tools"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action Cancellation"}),": Implement proper cancellation handling in action servers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Timeouts"}),": Add appropriate timeout handling in service clients"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"extensions-and-advanced-challenges",children:"Extensions and Advanced Challenges"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Real-time Performance"}),": Configure the system for real-time operation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-robot Communication"}),": Extend to multiple robots communicating with each other"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Security Implementation"}),": Add ROS 2 security features to the system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Distributed Computing"}),": Implement the system across multiple computers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Formal Verification"}),": Verify properties of the communication system"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references-and-further-reading",children:"References and Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["ROS 2 Documentation: ",(0,t.jsx)(n.a,{href:"https://docs.ros.org/",children:"https://docs.ros.org/"})]}),"\n",(0,t.jsxs)(n.li,{children:["DDS Specification: ",(0,t.jsx)(n.a,{href:"https://www.omg.org/spec/DDS/",children:"https://www.omg.org/spec/DDS/"})]}),"\n",(0,t.jsx)(n.li,{children:"Siciliano, B., & Khatib, O. (2016). Springer Handbook of Robotics."}),"\n",(0,t.jsx)(n.li,{children:"Quigley, M., Gerkey, B., & Smart, W. D. (2015). Programming robots with ROS."}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>l});var s=o(6540);const t={},i=s.createContext(t);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);