"use strict";(globalThis.webpackChunkhumanoid_robotics_course=globalThis.webpackChunkhumanoid_robotics_course||[]).push([[3780],{624:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>t,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module-3-digital-twin-simulation/chapter-2","title":"Chapter 2: Gazebo Harmonic - Physics-Based Simulation","description":"Learning Objectives","source":"@site/docs/module-3-digital-twin-simulation/chapter-2.md","sourceDirName":"module-3-digital-twin-simulation","slug":"/module-3-digital-twin-simulation/chapter-2","permalink":"/humanoid-robotics-course/docs/module-3-digital-twin-simulation/chapter-2","draft":false,"unlisted":false,"editUrl":"https://github.com/RizSheik/humanoid-robotics-course/edit/main/docs/module-3-digital-twin-simulation/chapter-2.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Chapter 1: Introduction to Digital Twin Technology and Simulation Environments","permalink":"/humanoid-robotics-course/docs/module-3-digital-twin-simulation/chapter-1"},"next":{"title":"Chapter 3: Unity - Visualization-Rich Simulation Environments","permalink":"/humanoid-robotics-course/docs/module-3-digital-twin-simulation/chapter-3"}}');var o=i(4848),s=i(8453);const t={},r="Chapter 2: Gazebo Harmonic - Physics-Based Simulation",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"2.1 Introduction to Gazebo Harmonic",id:"21-introduction-to-gazebo-harmonic",level:2},{value:"2.1.1 Key Features of Gazebo Harmonic",id:"211-key-features-of-gazebo-harmonic",level:3},{value:"2.1.2 Architecture Overview",id:"212-architecture-overview",level:3},{value:"2.2 Installation and Configuration",id:"22-installation-and-configuration",level:2},{value:"2.2.1 System Requirements",id:"221-system-requirements",level:3},{value:"2.2.2 Installation Process",id:"222-installation-process",level:3},{value:"2.2.3 Basic Configuration",id:"223-basic-configuration",level:3},{value:"2.3 Robot Model Creation with URDF/SDF",id:"23-robot-model-creation-with-urdfsdf",level:2},{value:"2.3.1 Understanding URDF and SDF",id:"231-understanding-urdf-and-sdf",level:3},{value:"2.3.2 Converting URDF to SDF",id:"232-converting-urdf-to-sdf",level:3},{value:"2.4 Physics Configuration and Parameters",id:"24-physics-configuration-and-parameters",level:2},{value:"2.4.1 Physics Engine Selection",id:"241-physics-engine-selection",level:3},{value:"2.4.2 Physics Parameters",id:"242-physics-parameters",level:3},{value:"2.4.3 Material and Surface Properties",id:"243-material-and-surface-properties",level:3},{value:"2.5 Sensor Integration and Simulation",id:"25-sensor-integration-and-simulation",level:2},{value:"2.5.1 Camera Simulation",id:"251-camera-simulation",level:3},{value:"2.5.2 LIDAR Simulation",id:"252-lidar-simulation",level:3},{value:"2.5.3 IMU and Force/Torque Sensors",id:"253-imu-and-forcetorque-sensors",level:3},{value:"2.6 Custom Plugins Development",id:"26-custom-plugins-development",level:2},{value:"2.6.1 Model Plugins",id:"261-model-plugins",level:3},{value:"2.6.2 Sensor Plugins",id:"262-sensor-plugins",level:3},{value:"2.7 Performance Optimization",id:"27-performance-optimization",level:2},{value:"2.7.1 Simulation Parameters for Performance",id:"271-simulation-parameters-for-performance",level:3},{value:"2.7.2 Visualization Settings",id:"272-visualization-settings",level:3},{value:"2.7.3 Model Simplification",id:"273-model-simplification",level:3},{value:"2.8 ROS 2 Integration",id:"28-ros-2-integration",level:2},{value:"2.8.1 Ignition Transport to ROS 2 Bridge",id:"281-ignition-transport-to-ros-2-bridge",level:3},{value:"2.8.2 Launch Files for Gazebo Integration",id:"282-launch-files-for-gazebo-integration",level:3},{value:"2.9 Validation and Calibration",id:"29-validation-and-calibration",level:2},{value:"2.9.1 Model Validation Techniques",id:"291-model-validation-techniques",level:3},{value:"2.9.2 Parameter Calibration",id:"292-parameter-calibration",level:3},{value:"2.9.3 Sim-to-Real Transfer Validation",id:"293-sim-to-real-transfer-validation",level:3},{value:"2.10 Advanced Topics",id:"210-advanced-topics",level:2},{value:"2.10.1 Multi-Robot Simulation",id:"2101-multi-robot-simulation",level:3},{value:"2.10.2 Domain Randomization",id:"2102-domain-randomization",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-2-gazebo-harmonic---physics-based-simulation",children:"Chapter 2: Gazebo Harmonic - Physics-Based Simulation"})}),"\n",(0,o.jsx)("div",{className:"robotDiagram",children:(0,o.jsx)("img",{src:"../../../img/book-image/Illustration_explaining_Physical_AI_huma_1.jpg",alt:"Humanoid Robot",style:{borderRadius:"50px",width:"900px",height:"350px",margin:"10px auto",display:"block"}})}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Configure and operate Gazebo Harmonic simulation environment"}),"\n",(0,o.jsx)(e.li,{children:"Create accurate robot models using URDF and SDF formats"}),"\n",(0,o.jsx)(e.li,{children:"Implement realistic physics simulation with appropriate parameters"}),"\n",(0,o.jsx)(e.li,{children:"Develop custom sensors and plugins for specialized applications"}),"\n",(0,o.jsx)(e.li,{children:"Optimize simulation performance for real-time operation"}),"\n",(0,o.jsx)(e.li,{children:"Evaluate and validate simulation models against real-world behavior"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"21-introduction-to-gazebo-harmonic",children:"2.1 Introduction to Gazebo Harmonic"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo Harmonic is a state-of-the-art physics-based simulation environment designed for robotics research and development. As part of the Open Robotics ecosystem, it provides a complete solution for simulating robots in 3D environments with realistic physics, sensors, and interaction capabilities."}),"\n",(0,o.jsx)(e.h3,{id:"211-key-features-of-gazebo-harmonic",children:"2.1.1 Key Features of Gazebo Harmonic"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Physics Engine"}),": Based on Ignition Physics, offering multiple backend physics engines (DART, Bullet) with accurate collision detection, contact simulation, and dynamics modeling."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Sensor Simulation"}),": Comprehensive support for various sensor types including cameras, LIDAR, IMU, force/torque sensors, GPS, and more, with realistic noise models and parameters."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Modular Architecture"}),": Component-based design allowing customization of physics, rendering, and other simulation aspects using plugins."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"ROS 2 Integration"}),": Native support for ROS 2 through Ignition Transport (which bridges to ROS 2 topics), making it straightforward to connect simulation to ROS 2-based robot code."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Scalability"}),": Support for simulating multiple robots simultaneously and distributed simulation across multiple machines."]}),"\n",(0,o.jsx)(e.h3,{id:"212-architecture-overview",children:"2.1.2 Architecture Overview"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo Harmonic has a modular architecture consisting of:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gazebo Server"}),": Core simulation engine that handles physics, sensors, and plugin execution"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gazebo Client"}),": User interface for visualization and interaction"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fuel Server"}),": Online model database for sharing robot models and environments"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Transport Layer"}),": Message passing system based on Ignition Transport, bridging to ROS 2"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"22-installation-and-configuration",children:"2.2 Installation and Configuration"}),"\n",(0,o.jsx)(e.h3,{id:"221-system-requirements",children:"2.2.1 System Requirements"}),"\n",(0,o.jsx)(e.p,{children:"To run Gazebo Harmonic effectively:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"CPU"}),": Multi-core processor (Intel i5 or equivalent recommended)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Memory"}),": 8GB+ RAM (16GB+ for complex simulations)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"GPU"}),": OpenGL 3.3+ capable graphics card with dedicated VRAM"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"OS"}),": Ubuntu 22.04 (recommended) or other supported Linux distributions"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"222-installation-process",children:"2.2.2 Installation Process"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo Harmonic is typically installed as part of a ROS 2 installation or separately:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Install via package manager\nsudo apt-get update\nsudo apt-get install ros-humble-gazebo-*\n\n# Or install as part of ROS 2 desktop installation\nsudo apt-get install ros-humble-desktop\n"})}),"\n",(0,o.jsx)(e.h3,{id:"223-basic-configuration",children:"2.2.3 Basic Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo Harmonic can be configured through environment variables and launch files:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Set Gazebo resource paths\nexport GZ_SIM_RESOURCE_PATH=/path/to/models:/path/to/worlds\nexport GZ_SIM_SYSTEM_PLUGIN_PATH=/path/to/plugins\n\n# Set specific physics engine (optional)\nexport GZ_PHYSICS_ENGINE_NAME=libignition-physics-dartsim-plugin.so\n"})}),"\n",(0,o.jsx)(e.h2,{id:"23-robot-model-creation-with-urdfsdf",children:"2.3 Robot Model Creation with URDF/SDF"}),"\n",(0,o.jsx)(e.h3,{id:"231-understanding-urdf-and-sdf",children:"2.3.1 Understanding URDF and SDF"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"URDF (Unified Robot Description Format)"})," is an XML-based format primarily used for robot kinematics and basic dynamics. It's well-integrated with ROS 2 tools and is typically used for robot description."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example URDF snippet --\x3e\n<robot name="simple_robot">\n  <link name="base_link">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0"/>\n      <geometry>\n        <box size="0.5 0.5 0.5"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0"/>\n      <geometry>\n        <box size="0.5 0.5 0.5"/>\n      </geometry>\n    </collision>\n  </link>\n  \n  <joint name="joint1" type="revolute">\n    <parent link="base_link"/>\n    <child link="arm_link"/>\n    <origin xyz="0.25 0 0" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>\n  </joint>\n</robot>\n'})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"SDF (Simulation Description Format)"})," is the native Gazebo format that extends URDF capabilities with simulation-specific features like joints, transmission systems, sensors, and plugins:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example SDF snippet --\x3e\n<sdf version="1.7">\n  <model name="simple_robot">\n    <link name="base_link">\n      <inertial>\n        <mass>1.0</mass>\n        <inertia>\n          <ixx>0.01</ixx>\n          <ixy>0</ixy>\n          <ixz>0</ixz>\n          <iyy>0.01</iyy>\n          <iyz>0</iyz>\n          <izz>0.01</izz>\n        </inertia>\n      </inertial>\n      \n      <visual name="visual">\n        <geometry>\n          <box><size>0.5 0.5 0.5</size></box>\n        </geometry>\n      </visual>\n      \n      <collision name="collision">\n        <geometry>\n          <box><size>0.5 0.5 0.5</size></box>\n        </geometry>\n      </collision>\n      \n      <sensor name="imu_sensor" type="imu">\n        <always_on>true</always_on>\n        <update_rate>100</update_rate>\n        <imu>\n          <angular_velocity>\n            <x>\n              <noise type="gaussian">\n                <mean>0.0</mean>\n                <stddev>2e-4</stddev>\n              </noise>\n            </x>\n          </angular_velocity>\n        </imu>\n      </sensor>\n    </link>\n  </model>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"232-converting-urdf-to-sdf",children:"2.3.2 Converting URDF to SDF"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo typically uses SDF for simulation, but URDF can be converted automatically:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:'# Convert URDF to SDF\ngz sdf -p robot.urdf > robot.sdf\n\n# Or include URDF in SDF world file\n<sdf version="1.7">\n  <world name="default">\n    <include>\n      <uri>model://robot_model</uri>\n      <pose>0 0 1 0 0 0</pose>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"24-physics-configuration-and-parameters",children:"2.4 Physics Configuration and Parameters"}),"\n",(0,o.jsx)(e.h3,{id:"241-physics-engine-selection",children:"2.4.1 Physics Engine Selection"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo Harmonic supports multiple physics engines:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"}),": Recommended for most robotics applications, especially for complex contact handling"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Bullet"}),": Good for faster simulation, suitable for simpler contact scenarios"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"ODE"}),": Older but stable, good for basic rigid body simulation"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"242-physics-parameters",children:"2.4.2 Physics Parameters"}),"\n",(0,o.jsx)(e.p,{children:"The physics engine can be configured with parameters to balance accuracy and performance:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Physics configuration in world file --\x3e\n<physics type="ignored">\n  <max_step_size>0.001</max_step_size>      \x3c!-- Simulation time step --\x3e\n  <real_time_factor>1.0</real_time_factor>  \x3c!-- Real-time simulation speed --\x3e\n  <real_time_update_rate>1000</real_time_update_rate> \x3c!-- Updates per second --\x3e\n  \n  \x3c!-- Solver settings --\x3e\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>10</iters>        \x3c!-- Iterations for constraint solving --\x3e\n      <sor>1.3</sor>           \x3c!-- Successive over-relaxation parameter --\x3e\n    </solver>\n    <constraints>\n      <cfm>0.0</cfm>           \x3c!-- Constraint force mixing --\x3e\n      <erp>0.2</erp>           \x3c!-- Error reduction parameter --\x3e\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"243-material-and-surface-properties",children:"2.4.3 Material and Surface Properties"}),"\n",(0,o.jsx)(e.p,{children:"Surface properties affect how objects interact:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:"\x3c!-- Surface properties --\x3e\n<surface>\n  <friction>\n    <ode>\n      <mu>1.0</mu>            \x3c!-- Static friction coefficient --\x3e\n      <mu2>1.0</mu2>          \x3c!-- Secondary friction coefficient --\x3e\n      <slip1>0.0</slip1>      \x3c!-- Primary slip coefficient --\x3e\n      <slip2>0.0</slip2>      \x3c!-- Secondary slip coefficient --\x3e\n    </ode>\n  </friction>\n  <bounce>\n    <restitution_coefficient>0.0</restitution_coefficient>\n    <threshold>100000</threshold>\n  </bounce>\n  <contact>\n    <ode>\n      <soft_cfm>0.0</soft_cfm>\n      <soft_erp>0.2</soft_erp>\n      <kp>1000000000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n      <kd>1.0</kd>              \x3c!-- Damping coefficient --\x3e\n      <max_vel>100.0</max_vel>\n      <min_depth>0.001</min_depth>\n    </ode>\n  </contact>\n</surface>\n"})}),"\n",(0,o.jsx)(e.h2,{id:"25-sensor-integration-and-simulation",children:"2.5 Sensor Integration and Simulation"}),"\n",(0,o.jsx)(e.h3,{id:"251-camera-simulation",children:"2.5.1 Camera Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo provides realistic camera simulation with various parameters:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<sensor name="camera" type="camera">\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>  \x3c!-- Field of view in radians --\x3e\n    <image>\n      <width>640</width>\n      <height>480</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>100</far>\n    </clip>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.007</stddev>\n    </noise>\n  </camera>\n  <always_on>true</always_on>\n  <update_rate>30</update_rate>\n  <visualize>true</visualize>\n</sensor>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"252-lidar-simulation",children:"2.5.2 LIDAR Simulation"}),"\n",(0,o.jsx)(e.p,{children:"LIDAR sensors can be configured with detailed parameters:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<sensor name="laser" type="ray">\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>720</samples>\n        <resolution>1</resolution>\n        <min_angle>-1.570796</min_angle>\n        <max_angle>1.570796</max_angle>\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n  </ray>\n  <plugin filename="libignition-gazebo-ray-sensor-system.so" name="ignition::gazebo::systems::RaySensor">\n    <ros>\n      <namespace>/robot1</namespace>\n      <remapping>~/out@sensor_msgs/msg/LaserScan@ignition.msgs.LaserScan</remapping>\n    </ros>\n  </plugin>\n  <always_on>true</always_on>\n  <update_rate>10</update_rate>\n  <visualize>true</visualize>\n</sensor>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"253-imu-and-forcetorque-sensors",children:"2.5.3 IMU and Force/Torque Sensors"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<sensor name="imu_sensor" type="imu">\n  <always_on>true</always_on>\n  <update_rate>100</update_rate>\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n        </noise>\n      </z>\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n        </noise>\n      </z>\n    </linear_acceleration>\n  </imu>\n</sensor>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"26-custom-plugins-development",children:"2.6 Custom Plugins Development"}),"\n",(0,o.jsx)(e.h3,{id:"261-model-plugins",children:"2.6.1 Model Plugins"}),"\n",(0,o.jsx)(e.p,{children:"Model plugins extend robot behavior:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"#include <ignition/gazebo/Model.hh>\n#include <ignition/gazebo/System.hh>\n#include <ignition/math/Pose3.hh>\n#include <sdf/sdf.hh>\n\nnamespace gazebo_class\n{\n  class CustomController : public ignition::gazebo::System,\n                          public ignition::gazebo::ISystemConfigure,\n                          public ignition::gazebo::ISystemPreUpdate\n  {\n    public: void Configure(const ignition::gazebo::Entity &_entity,\n                          const std::shared_ptr<const sdf::Element> &_sdf,\n                          ignition::gazebo::EntityComponentManager &_ecm,\n                          ignition::gazebo::EventManager &_eventMgr) override\n    {\n      // Initialize the controller\n      this->model = ignition::gazebo::Model(_entity);\n    }\n\n    public: void PreUpdate(const ignition::gazebo::UpdateInfo &_info,\n                          ignition::gazebo::EntityComponentManager &_ecm) override\n    {\n      // Custom control logic executed before each simulation step\n      // This is where control algorithms are typically implemented\n    }\n\n    private: ignition::gazebo::Model model;\n  };\n}\n\n// Register the plugin\nIGNITION_ADD_PLUGIN(gazebo_class::CustomController,\n                  ignition::gazebo::System,\n                  CustomController::ISystemConfigure,\n                  CustomController::ISystemPreUpdate)\n"})}),"\n",(0,o.jsx)(e.h3,{id:"262-sensor-plugins",children:"2.6.2 Sensor Plugins"}),"\n",(0,o.jsx)(e.p,{children:"Sensor plugins process sensor data:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"#include <ignition/gazebo/System.hh>\n#include <ignition/sensors/CameraSensor.hh>\n#include <ignition/transport/Node.hh>\n\nnamespace gazebo_class\n{\n  class CustomCameraProcessor : public ignition::gazebo::System,\n                                public ignition::gazebo::ISystemPreUpdate\n  {\n    public: void PreUpdate(const ignition::gazebo::UpdateInfo &_info,\n                          ignition::gazebo::EntityComponentManager &_ecm) override\n    {\n      // Process camera data\n      // Apply custom image processing algorithms\n    }\n  };\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"27-performance-optimization",children:"2.7 Performance Optimization"}),"\n",(0,o.jsx)(e.h3,{id:"271-simulation-parameters-for-performance",children:"2.7.1 Simulation Parameters for Performance"}),"\n",(0,o.jsx)(e.p,{children:"Balance accuracy and performance with these settings:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Performance-optimized physics settings --\x3e\n<physics type="dartsim">\n  <max_step_size>0.01</max_step_size>        \x3c!-- Larger steps for performance --\x3e\n  <real_time_factor>1.0</real_time_factor>   \x3c!-- Target real-time simulation --\x3e\n  <real_time_update_rate>100</real_time_update_rate>  \x3c!-- Lower update rate --\x3e\n  \n  <dartsim>\n    <solver>\n      <type>PGS</type>                        \x3c!-- Fast solver type --\x3e\n      <iterations>50</iterations>              \x3c!-- Fewer iterations --\x3e\n      <sor>1.2</sor>                          \x3c!-- Lower SOR parameter --\x3e\n    </solver>\n  </dartsim>\n</physics>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"272-visualization-settings",children:"2.7.2 Visualization Settings"}),"\n",(0,o.jsx)(e.p,{children:"Optimize rendering for performance:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Disable rendering for headless operation\ngazebo --headless my_world.sdf\n\n# Or through environment variable\nexport GZ_GUI_PLUGIN_CAMERA_TRACKER_ENABLED=false\n"})}),"\n",(0,o.jsx)(e.h3,{id:"273-model-simplification",children:"2.7.3 Model Simplification"}),"\n",(0,o.jsx)(e.p,{children:"For performance-critical applications, simplify models:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Simplified collision geometry --\x3e\n<link name="simplified_link">\n  \x3c!-- Use simple shapes instead of complex meshes --\x3e\n  <collision>\n    <geometry>\n      <cylinder>\n        <radius>0.1</radius>\n        <length>0.5</length>\n      </cylinder>\n    </geometry>\n  </collision>\n  \n  \x3c!-- Detailed visual geometry --\x3e\n  <visual>\n    <geometry>\n      <mesh>\n        <uri>model://complex_robot/meshes/detailed_link.dae</uri>\n      </mesh>\n    </geometry>\n  </visual>\n</link>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"28-ros-2-integration",children:"2.8 ROS 2 Integration"}),"\n",(0,o.jsx)(e.h3,{id:"281-ignition-transport-to-ros-2-bridge",children:"2.8.1 Ignition Transport to ROS 2 Bridge"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo Harmonic uses Ignition Transport, which bridges to ROS 2:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example of ROS 2 bridge configuration in SDF --\x3e\n<model name="robot_with_ros">\n  <plugin filename="libignition-gazebo-joint-position-controller-system.so" \n          name="ignition::gazebo::systems::JointPositionController">\n    <ros>\n      <namespace>/my_robot</namespace>\n      <remapping>cmd_pos@std_msgs/msg/Float64@ignition.msgs.Double</remapping>\n    </ros>\n  </plugin>\n  \n  <plugin filename="libignition-gazebo-joint-state-publisher-system.so"\n          name="ignition::gazebo::systems::JointStatePublisher">\n    <ros>\n      <namespace>/my_robot</namespace>\n    </ros>\n  </plugin>\n</model>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"282-launch-files-for-gazebo-integration",children:"2.8.2 Launch Files for Gazebo Integration"}),"\n",(0,o.jsx)(e.p,{children:"Creating launch files to integrate Gazebo with ROS 2 systems:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# launch/gazebo_simulation.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch Gazebo\n    gazebo_launch = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('ros_gz_sim'),\n                'launch',\n                'gz_sim.launch.py'\n            ])\n        ]),\n        launch_arguments={'gz_args': ' -r empty.sdf'}.items()\n    )\n    \n    # Spawn robot in Gazebo\n    spawn_entity = Node(\n        package='ros_gz_sim',\n        executable='create',\n        arguments=[\n            '-name', 'my_robot',\n            '-file', PathJoinSubstitution([\n                FindPackageShare('my_robot_description'),\n                'urdf',\n                'my_robot.urdf'\n            ])\n        ],\n        output='screen'\n    )\n    \n    return LaunchDescription([\n        gazebo_launch,\n        spawn_entity,\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"29-validation-and-calibration",children:"2.9 Validation and Calibration"}),"\n",(0,o.jsx)(e.h3,{id:"291-model-validation-techniques",children:"2.9.1 Model Validation Techniques"}),"\n",(0,o.jsx)(e.p,{children:"Validating simulation models against real robot behavior:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Kinematic Validation"}),": Verify joint limits and ranges of motion match real robot"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamic Validation"}),": Compare motion with real robot under same control inputs"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensor Validation"}),": Ensure simulated sensors match real sensor characteristics"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"292-parameter-calibration",children:"2.9.2 Parameter Calibration"}),"\n",(0,o.jsx)(e.p,{children:"Calibrating simulation parameters to match reality:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# Example of system identification to calibrate simulation parameters\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef simulation_error(params):\n    """Calculate error between simulation and real robot"""\n    # Update simulation with new parameters\n    update_simulation_params(params)\n    \n    # Run simulation and collect data\n    sim_data = run_simulation()\n    \n    # Compare with real robot data\n    real_data = get_real_robot_data()\n    \n    # Calculate error\n    error = np.mean((sim_data - real_data) ** 2)\n    return error\n\n# Optimize parameters to minimize simulation error\nresult = minimize(simulation_error, initial_guess, method=\'BFGS\')\ncalibrated_params = result.x\n'})}),"\n",(0,o.jsx)(e.h3,{id:"293-sim-to-real-transfer-validation",children:"2.9.3 Sim-to-Real Transfer Validation"}),"\n",(0,o.jsx)(e.p,{children:"Testing sim-to-real transfer effectiveness:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Train controller in simulation"}),"\n",(0,o.jsx)(e.li,{children:"Deploy directly to real robot without modification"}),"\n",(0,o.jsx)(e.li,{children:"Measure performance degradation"}),"\n",(0,o.jsx)(e.li,{children:"Iterate simulation model improvements"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"210-advanced-topics",children:"2.10 Advanced Topics"}),"\n",(0,o.jsx)(e.h3,{id:"2101-multi-robot-simulation",children:"2.10.1 Multi-Robot Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Simulating multiple robots with proper communication:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Multi-robot world file --\x3e\n<sdf version="1.7">\n  <world name="multi_robot">\n    <include>\n      <name>robot1</name>\n      <uri>model://turtlebot3_waffle</uri>\n      <pose>0 0 0 0 0 0</pose>\n    </include>\n    \n    <include>\n      <name>robot2</name>\n      <uri>model://turtlebot3_waffle</uri>\n      <pose>1 0 0 0 0 0</pose>\n    </include>\n    \n    <physics type="dartsim">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n    </physics>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"2102-domain-randomization",children:"2.10.2 Domain Randomization"}),"\n",(0,o.jsx)(e.p,{children:"Implementing domain randomization for robust sim-to-real transfer:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example of domain randomization in Gazebo --\x3e\n<model name="randomized_box">\n  <link name="link">\n    <inertial>\n      <mass>__random_mass__</mass>\n      <inertia>\n        <ixx>__random_ixx__</ixx>\n        <iyy>__random_iyy__</iyy>\n        <izz>__random_izz__</izz>\n        \x3c!-- Other inertia values --\x3e\n      </inertia>\n    </inertial>\n    \n    <collision name="collision">\n      <geometry>\n        <box>\n          <size>__random_size_x__ __random_size_y__ __random_size_z__</size>\n        </box>\n      </geometry>\n    </collision>\n  </link>\n</model>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,o.jsx)(e.p,{children:"This chapter provided a comprehensive overview of Gazebo Harmonic as a physics-based simulation environment for robotics. We covered installation and configuration, robot model creation using URDF and SDF, physics configuration, sensor integration, custom plugin development, performance optimization, and ROS 2 integration. The chapter concluded with validation techniques and advanced topics including multi-robot simulation and domain randomization."}),"\n",(0,o.jsx)(e.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Gazebo Harmonic"}),"\n",(0,o.jsx)(e.li,{children:"URDF (Unified Robot Description Format)"}),"\n",(0,o.jsx)(e.li,{children:"SDF (Simulation Description Format)"}),"\n",(0,o.jsx)(e.li,{children:"Physics Engine"}),"\n",(0,o.jsx)(e.li,{children:"Sensor Simulation"}),"\n",(0,o.jsx)(e.li,{children:"Model Plugins"}),"\n",(0,o.jsx)(e.li,{children:"ROS 2 Integration"}),"\n",(0,o.jsx)(e.li,{children:"Sim-to-Real Transfer"}),"\n",(0,o.jsx)(e.li,{children:"Domain Randomization"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Create a simple robot model in URDF and simulate it in Gazebo"}),"\n",(0,o.jsx)(e.li,{children:"Implement a custom controller plugin for a differential drive robot"}),"\n",(0,o.jsx)(e.li,{children:"Configure a multi-sensor robot with camera, LIDAR, and IMU"}),"\n",(0,o.jsx)(e.li,{children:"Validate a simulation model against real robot data and calibrate parameters"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Gazebo Harmonic Documentation: ",(0,o.jsx)(e.a,{href:"http://gazebosim.org/",children:"http://gazebosim.org/"})]}),"\n",(0,o.jsxs)(e.li,{children:["Ignition Robotics Documentation: ",(0,o.jsx)(e.a,{href:"https://ignitionrobotics.org/",children:"https://ignitionrobotics.org/"})]}),"\n",(0,o.jsx)(e.li,{children:"Open Source Robotics Foundation. (2023). Gazebo Harmonic Release Notes."}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>r});var a=i(6540);const o={},s=a.createContext(o);function t(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:t(n.components),a.createElement(s.Provider,{value:e},n.children)}}}]);