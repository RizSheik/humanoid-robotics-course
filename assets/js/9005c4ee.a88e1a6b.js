"use strict";(globalThis.webpackChunkhumanoid_robotics_course=globalThis.webpackChunkhumanoid_robotics_course||[]).push([[3038],{6011:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2-ros-2-fundamentals/chapter-4","title":"Chapter 4: Actions and Complex Task Execution","description":"Learning Objectives","source":"@site/docs/module-2-ros-2-fundamentals/chapter-4.md","sourceDirName":"module-2-ros-2-fundamentals","slug":"/module-2-ros-2-fundamentals/chapter-4","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/chapter-4","draft":false,"unlisted":false,"editUrl":"https://github.com/RizSheik/humanoid-robotics-course/edit/main/docs/module-2-ros-2-fundamentals/chapter-4.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Chapter 3: Services and Synchronous Communication","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/chapter-3"},"next":{"title":"Module 2: Deep Dive - Advanced ROS 2 Concepts for Complex Robotics Systems","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/deep-dive"}}');var i=t(4848),r=t(8453);const a={},s="Chapter 4: Actions and Complex Task Execution",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"4.1 Understanding Actions in ROS 2",id:"41-understanding-actions-in-ros-2",level:2},{value:"4.1.1 Characteristics of Action Communication",id:"411-characteristics-of-action-communication",level:3},{value:"4.1.2 When to Use Actions",id:"412-when-to-use-actions",level:3},{value:"4.2 Action Types and Standard Interfaces",id:"42-action-types-and-standard-interfaces",level:2},{value:"4.2.1 Action Message Components",id:"421-action-message-components",level:3},{value:"4.2.2 Standard Action Types",id:"422-standard-action-types",level:3},{value:"4.3 Implementing Action Servers",id:"43-implementing-action-servers",level:2},{value:"4.3.1 Basic Action Server (Python)",id:"431-basic-action-server-python",level:3},{value:"4.3.2 Complex Action Server Example",id:"432-complex-action-server-example",level:3},{value:"4.4 Implementing Action Clients",id:"44-implementing-action-clients",level:2},{value:"4.4.1 Basic Action Client (Python)",id:"441-basic-action-client-python",level:3},{value:"4.4.2 Asynchronous Action Client with Preemption",id:"442-asynchronous-action-client-with-preemption",level:3},{value:"4.5 Advanced Action Concepts",id:"45-advanced-action-concepts",level:2},{value:"4.5.1 Action with Complex Feedback",id:"451-action-with-complex-feedback",level:3},{value:"4.5.2 Action Composition",id:"452-action-composition",level:3},{value:"4.6 Action Design for Humanoid Robots",id:"46-action-design-for-humanoid-robots",level:2},{value:"4.6.1 Walking Pattern Generation Action",id:"461-walking-pattern-generation-action",level:3},{value:"4.6.2 Whole-Body Motion Action",id:"462-whole-body-motion-action",level:3},{value:"4.6.3 Humanoid Action Server Implementation",id:"463-humanoid-action-server-implementation",level:3},{value:"4.7 Performance and Reliability Considerations",id:"47-performance-and-reliability-considerations",level:2},{value:"4.7.1 Resource Management",id:"471-resource-management",level:3},{value:"4.7.2 Error Recovery",id:"472-error-recovery",level:3},{value:"4.8 Best Practices for Action Development",id:"48-best-practices-for-action-development",level:2},{value:"4.8.1 Action Interface Design",id:"481-action-interface-design",level:3},{value:"4.8.2 Implementation Guidelines",id:"482-implementation-guidelines",level:3},{value:"4.8.3 Performance Considerations",id:"483-performance-considerations",level:3},{value:"4.9 Comparing Communication Patterns",id:"49-comparing-communication-patterns",level:2},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-4-actions-and-complex-task-execution",children:"Chapter 4: Actions and Complex Task Execution"})}),"\n",(0,i.jsx)("div",{className:"robotDiagram",children:(0,i.jsx)("img",{src:"../../../img/book-image/Highquality_infographic_of_ROS_2_archite_1.jpg",alt:"Humanoid Robot",style:{borderRadius:"50px",width:"900px",height:"350px",margin:"10px auto",display:"block"}})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement action servers and clients in ROS 2 for long-running tasks"}),"\n",(0,i.jsx)(n.li,{children:"Design appropriate action interfaces for complex robot operations"}),"\n",(0,i.jsx)(n.li,{children:"Handle goal, feedback, and result patterns in robotic applications"}),"\n",(0,i.jsx)(n.li,{children:"Manage action lifecycle including preemption and cancellation"}),"\n",(0,i.jsx)(n.li,{children:"Integrate actions into humanoid robot task planning and execution"}),"\n",(0,i.jsx)(n.li,{children:"Compare when to use actions versus topics or services"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"41-understanding-actions-in-ros-2",children:"4.1 Understanding Actions in ROS 2"}),"\n",(0,i.jsx)(n.p,{children:"Actions in ROS 2 provide a communication pattern for long-running tasks that require feedback and the ability to be preempted. Unlike services, which are synchronous, or topics, which are asynchronous without built-in request-response patterns, actions combine the best of both approaches."}),"\n",(0,i.jsx)(n.h3,{id:"411-characteristics-of-action-communication",children:"4.1.1 Characteristics of Action Communication"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Long-running"}),": Designed for tasks that take seconds, minutes, or longer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goal-oriented"}),": Client sends a goal, server executes it"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback-enabled"}),": Server provides continuous feedback during execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Preemptable"}),": Goals can be canceled or preempted by new goals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result-returning"}),": Server returns a final result when task completes"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"412-when-to-use-actions",children:"4.1.2 When to Use Actions"}),"\n",(0,i.jsx)(n.p,{children:"Actions are appropriate when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The operation takes a significant amount of time"}),"\n",(0,i.jsx)(n.li,{children:"You need to monitor progress during execution"}),"\n",(0,i.jsx)(n.li,{children:"The operation might need to be canceled or changed"}),"\n",(0,i.jsx)(n.li,{children:"You need to distinguish between different goals for the same task"}),"\n",(0,i.jsx)(n.li,{children:"The task has intermediate results worth reporting"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"42-action-types-and-standard-interfaces",children:"4.2 Action Types and Standard Interfaces"}),"\n",(0,i.jsx)(n.h3,{id:"421-action-message-components",children:"4.2.1 Action Message Components"}),"\n",(0,i.jsx)(n.p,{children:"Each action type consists of three message definitions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goal"}),": Parameters for the action"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback"}),": Status during action execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result"}),": Final outcome of the action"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Example action definition (",(0,i.jsx)(n.code,{children:"Fibonacci.action"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"#goal definition\nint32 order\n---\n#feedback\nint32[] sequence\n---\n#result\nint32[] sequence\n"})}),"\n",(0,i.jsx)(n.h3,{id:"422-standard-action-types",children:"4.2.2 Standard Action Types"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 provides common action types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"control_msgs/action/FollowJointTrajectory"}),": Execute joint trajectories"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"control_msgs/action/PointHead"}),": Point a sensor in a specific direction"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"move_base_msgs/action/MoveBase"}),": Navigate to a position"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nav2_msgs/action/ComputePathToPose"}),": Plan a navigation path"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"example_interfaces/action/Fibonacci"}),": Example action for learning"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"43-implementing-action-servers",children:"4.3 Implementing Action Servers"}),"\n",(0,i.jsx)(n.h3,{id:"431-basic-action-server-python",children:"4.3.1 Basic Action Server (Python)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import time\nimport rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            execute_callback=self.execute_callback,\n            callback_group=rclpy.callback_groups.ReentrantCallbackGroup(),\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback)\n\n    def destroy(self):\n        self._action_server.destroy()\n        super().destroy_node()\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject a client request to begin an action.\"\"\"\n        self.get_logger().info('Received goal request')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Accept or reject a client request to cancel an action.\"\"\"\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute the goal.\"\"\"\n        self.get_logger().info('Executing goal...')\n        \n        # Feedback and result messages\n        feedback_msg = Fibonacci.Feedback()\n        result_msg = Fibonacci.Result()\n        \n        # Initialize Fibonacci sequence\n        feedback_msg.sequence = [0, 1]\n        sequence = [0, 1]\n        \n        # Start executing the action\n        for i in range(1, goal_handle.request.order):\n            # Check if the goal has been canceled\n            if goal_handle.is_cancel_requested:\n                result_msg.sequence = sequence\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return result_msg\n\n            # Update Fibonacci sequence\n            sequence.append(sequence[i] + sequence[i-1])\n            feedback_msg.sequence = sequence\n            \n            # Publish feedback\n            goal_handle.publish_feedback(feedback_msg)\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\n            \n            # Sleep to simulate work\n            time.sleep(1)\n        \n        # Check if goal was canceled during execution\n        if goal_handle.is_cancel_requested:\n            result_msg.sequence = sequence\n            goal_handle.canceled()\n            self.get_logger().info('Goal canceled')\n            return result_msg\n        \n        # Set result and succeed\n        result_msg.sequence = sequence\n        goal_handle.succeed()\n        self.get_logger().info('Returning result: {result_msg.sequence}')\n        \n        return result_msg\n\ndef main(args=None):\n    rclpy.init(args=args)\n    fibonacci_action_server = FibonacciActionServer()\n    \n    try:\n        rclpy.spin(fibonacci_action_server)\n    except KeyboardInterrupt:\n        fibonacci_action_server.get_logger().info('Interrupted by user')\n    finally:\n        fibonacci_action_server.destroy()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"432-complex-action-server-example",children:"4.3.2 Complex Action Server Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\n\nclass JointTrajectoryActionServer(Node):\n    def __init__(self):\n        super().__init__('joint_trajectory_action_server')\n        self._action_server = ActionServer(\n            self,\n            FollowJointTrajectory,\n            'joint_trajectory_controller/follow_joint_trajectory',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback)\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject goal based on trajectory validity.\"\"\"\n        # Validate the incoming trajectory\n        trajectory = goal_request.trajectory\n        \n        if len(trajectory.joint_names) == 0:\n            self.get_logger().warn('Goal rejected: No joint names specified')\n            return GoalResponse.REJECT\n        \n        if len(trajectory.points) == 0:\n            self.get_logger().warn('Goal rejected: No trajectory points specified')\n            return GoalResponse.REJECT\n        \n        self.get_logger().info('Goal accepted')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Accept all cancel requests.\"\"\"\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute the joint trajectory.\"\"\"\n        self.get_logger().info('Executing joint trajectory goal')\n        \n        # Get the trajectory from the goal\n        trajectory = goal_handle.request.trajectory\n        joint_names = trajectory.joint_names\n        points = trajectory.points\n        \n        # Initialize feedback\n        feedback_msg = FollowJointTrajectory.Feedback()\n        feedback_msg.joint_names = joint_names\n        feedback_msg.desired = JointTrajectoryPoint()\n        feedback_msg.actual = JointTrajectoryPoint()\n        feedback_msg.error = JointTrajectoryPoint()\n        \n        # Result message\n        result_msg = FollowJointTrajectory.Result()\n        result_msg.error_code = FollowJointTrajectory.Result.SUCCESSFUL\n        \n        # Execute the trajectory point by point\n        for i, point in enumerate(points):\n            # Check for cancellation\n            if goal_handle.is_cancel_requested:\n                result_msg.error_code = FollowJointTrajectory.Result.PATH_TOLERANCE_VIOLATED\n                goal_handle.canceled()\n                self.get_logger().info('Trajectory execution canceled')\n                return result_msg\n            \n            # Set feedback\n            feedback_msg.desired = point\n            feedback_msg.actual.positions = [0.0] * len(joint_names)  # Simulated actual positions\n            feedback_msg.error.positions = [0.0] * len(joint_names)    # Simulated error\n            \n            # Publish feedback\n            goal_handle.publish_feedback(feedback_msg)\n            \n            # Simulate moving to the trajectory point\n            # In real implementation, this would control actual joints\n            self.move_to_position(point, joint_names)\n            \n            self.get_logger().info(f'Completed trajectory point {i+1}/{len(points)}')\n        \n        # Check for final cancellation\n        if goal_handle.is_cancel_requested:\n            result_msg.error_code = FollowJointTrajectory.Result.PATH_TOLERANCE_VIOLATED\n            goal_handle.canceled()\n            return result_msg\n        \n        # Set result and succeed\n        goal_handle.succeed()\n        self.get_logger().info('Trajectory execution completed successfully')\n        \n        return result_msg\n\n    def move_to_position(self, point, joint_names):\n        \"\"\"Simulate or execute movement to the specified position.\"\"\"\n        # In a real implementation, this would interface with the robot's\n        # joint control system to move to the specified position\n        import time\n        time.sleep(0.5)  # Simulate movement time\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_server = JointTrajectoryActionServer()\n    \n    try:\n        rclpy.spin(action_server)\n    except KeyboardInterrupt:\n        action_server.get_logger().info('Interrupted by user')\n    finally:\n        action_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"44-implementing-action-clients",children:"4.4 Implementing Action Clients"}),"\n",(0,i.jsx)(n.h3,{id:"441-basic-action-client-python",children:"4.4.1 Basic Action Client (Python)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import time\nimport rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionClient(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\n\n    def send_goal(self, order):\n        # Wait for the action server to be available\n        self._action_client.wait_for_server()\n        \n        # Create the goal\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n        \n        # Send the goal and get a future\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n        \n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected')\n            return\n\n        self.get_logger().info('Goal accepted')\n        \n        # Get result future\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f'Received feedback: {feedback.sequence}')\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info(f'Result: {result.sequence}')\n        rclpy.shutdown()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_client = FibonacciActionClient()\n    \n    # Send goal\n    action_client.send_goal(10)\n    \n    # Spin to allow callbacks to be processed\n    rclpy.spin(action_client)\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"442-asynchronous-action-client-with-preemption",children:"4.4.2 Asynchronous Action Client with Preemption"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import time\nimport rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\n\nclass TrajectoryActionClient(Node):\n    def __init__(self):\n        super().__init__('trajectory_action_client')\n        self._action_client = ActionClient(\n            self, \n            FollowJointTrajectory, \n            'joint_trajectory_controller/follow_joint_trajectory')\n\n    def send_trajectory(self, joint_names, positions_list, time_from_start_list):\n        \"\"\"Send a joint trajectory to the robot.\"\"\"\n        # Wait for the action server to be available\n        self._action_client.wait_for_server()\n        \n        # Create the trajectory\n        trajectory = JointTrajectory()\n        trajectory.joint_names = joint_names\n        \n        # Add points to the trajectory\n        for pos, time_from_start in zip(positions_list, time_from_start_list):\n            point = JointTrajectoryPoint()\n            point.positions = pos\n            point.time_from_start = Duration(sec=time_from_start)\n            trajectory.points.append(point)\n        \n        # Create the goal\n        goal_msg = FollowJointTrajectory.Goal()\n        goal_msg.trajectory = trajectory\n        \n        # Send the goal\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n        \n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Trajectory goal rejected')\n            return\n\n        self.get_logger().info('Trajectory goal accepted')\n        self.goal_handle = goal_handle\n        \n        # Get result future\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        feedback = feedback_msg.feedback\n        self.get_logger().info(\n            f'Trajectory execution: {len(feedback.actual.positions)} joints active')\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        if result.error_code == FollowJointTrajectory.Result.SUCCESSFUL:\n            self.get_logger().info('Trajectory executed successfully')\n        else:\n            self.get_logger().info(f'Trajectory execution failed with error code: {result.error_code}')\n        \n        rclpy.shutdown()\n\n    def cancel_goal(self):\n        \"\"\"Cancel the current trajectory goal.\"\"\"\n        if hasattr(self, 'goal_handle'):\n            future = self.goal_handle.cancel_goal_async()\n            future.add_done_callback(self.cancel_response_callback)\n\n    def cancel_response_callback(self, future):\n        cancel_response = future.result()\n        if len(cancel_response.goals_canceling) > 0:\n            self.get_logger().info('Goal successfully canceled')\n        else:\n            self.get_logger().info('Goal failed to cancel')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_client = TrajectoryActionClient()\n    \n    # Example trajectory: move 2 joints through 3 positions\n    joint_names = ['joint1', 'joint2']\n    positions = [[0.0, 0.0], [1.0, 1.0], [0.0, 0.0]]  # Start, mid, end\n    times = [1, 2, 3]  # Execute at 1s, 2s, and 3s\n    \n    action_client.send_trajectory(joint_names, positions, times)\n    \n    # After 1.5 seconds, cancel the goal (for demonstration)\n    def cancel_goal():\n        time.sleep(1.5)\n        action_client.cancel_goal()\n    \n    # Run cancel in a separate thread\n    import threading\n    cancel_thread = threading.Thread(target=cancel_goal)\n    cancel_thread.start()\n    \n    # Spin to allow callbacks to be processed\n    rclpy.spin(action_client)\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"45-advanced-action-concepts",children:"4.5 Advanced Action Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"451-action-with-complex-feedback",children:"4.5.1 Action with Complex Feedback"}),"\n",(0,i.jsx)(n.p,{children:"For actions that need detailed feedback, create comprehensive feedback messages:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Custom action: ExecuteComplexTask.action\n# Goal\nstring task_name\nstring[] parameters\n---\n# Feedback\nstring current_step\nfloat64 progress_percentage\nstring status_message\nint32 execution_count\n---\n# Result\nbool success\nstring final_status\nint32 error_code\nfloat64[] final_values\n"})}),"\n",(0,i.jsx)(n.h3,{id:"452-action-composition",children:"4.5.2 Action Composition"}),"\n",(0,i.jsx)(n.p,{children:"Often, complex tasks require coordination of multiple actions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import asyncio\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\n\nclass TaskCoordinator(Node):\n    def __init__(self):\n        super().__init__('task_coordinator')\n        \n        # Multiple action clients for different subtasks\n        self.navigation_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\n        self.manipulation_client = ActionClient(self, MoveGroup, 'move_group')\n        self.perception_client = ActionClient(self, DetectObjects, 'detect_objects')\n\n    async def execute_complex_task(self, target_pose, object_to_grab):\n        \"\"\"Execute a complex task involving navigation, perception, and manipulation.\"\"\"\n        # Step 1: Navigate to target\n        nav_goal = NavigateToPose.Goal()\n        nav_goal.pose = target_pose\n        nav_future = await self.send_navigation_goal(nav_goal)\n        \n        if not nav_future.result().result.success:\n            return False  # Navigation failed\n        \n        # Step 2: Detect objects\n        detection_goal = DetectObjects.Goal()\n        detection_goal.roi = self.get_roi_from_pose(target_pose)\n        detection_future = await self.send_detection_goal(detection_goal)\n        \n        detected_objects = detection_future.result().result.objects\n        target_object = self.find_target_object(detected_objects, object_to_grab)\n        \n        if not target_object:\n            return False  # Object not found\n        \n        # Step 3: Manipulate object\n        manipulation_goal = MoveGroup.Goal()\n        manipulation_goal.target = self.calculate_grasp_pose(target_object)\n        manipulation_future = await self.send_manipulation_goal(manipulation_goal)\n        \n        return manipulation_future.result().result.success\n"})}),"\n",(0,i.jsx)(n.h2,{id:"46-action-design-for-humanoid-robots",children:"4.6 Action Design for Humanoid Robots"}),"\n",(0,i.jsx)(n.h3,{id:"461-walking-pattern-generation-action",children:"4.6.1 Walking Pattern Generation Action"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# GenerateWalkingPattern.action\n# Goal\nfloat64 step_length\nfloat64 step_height  \nfloat64 step_duration\nint32 num_steps\nbool is_turning\nfloat64 turn_angle\n---\n# Feedback\nint32 current_step\nfloat64 progress_percentage\nstring status\nbool is_balanced\n---\n# Result\nbool success\nstring error_message\ntrajectory_msgs/JointTrajectory walking_trajectory\n"})}),"\n",(0,i.jsx)(n.h3,{id:"462-whole-body-motion-action",children:"4.6.2 Whole-Body Motion Action"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# ExecuteWholeBodyMotion.action\n# Goal\nstring motion_name\nfloat64[] initial_positions\nfloat64[] target_positions\nfloat64 execution_time\nbool avoid_obstacles\n---\n# Feedback\nfloat64 progress_percentage\ngeometry_msgs/Pose current_pose\nstring status\nbool is_stable\n---\n# Result\nbool success\nstring error_message\nstring completion_status\n"})}),"\n",(0,i.jsx)(n.h3,{id:"463-humanoid-action-server-implementation",children:"4.6.3 Humanoid Action Server Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectoryPoint\n\nclass HumanoidMotionActionServer(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_motion_action_server\')\n        self._action_server = ActionServer(\n            self,\n            FollowJointTrajectory,\n            \'humanoid_controller/follow_joint_trajectory\',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback)\n\n    def goal_callback(self, goal_request):\n        """Validate humanoid motion goals."""\n        # Check joint limits and other constraints\n        trajectory = goal_request.trajectory\n        \n        for point in trajectory.points:\n            # Check each joint position against limits\n            for i, pos in enumerate(point.positions):\n                joint_name = trajectory.joint_names[i]\n                # Implement joint limit checking\n                if not self.is_within_joint_limits(joint_name, pos):\n                    self.get_logger().warn(f\'Joint {joint_name} position {pos} is out of limits\')\n                    return rclpy.action.GoalResponse.REJECT\n        \n        self.get_logger().info(\'Motion goal accepted\')\n        return rclpy.action.GoalResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        """Execute humanoid motion with balance control."""\n        self.get_logger().info(\'Executing humanoid motion\')\n        \n        # Initialize feedback\n        feedback_msg = FollowJointTrajectory.Feedback()\n        result_msg = FollowJointTrajectory.Result()\n        \n        # Get trajectory\n        trajectory = goal_handle.request.trajectory\n        joint_names = trajectory.joint_names\n        \n        # Initialize balance controller\n        self.start_balance_control()\n        \n        try:\n            # Execute trajectory point by point\n            for i, point in enumerate(trajectory.points):\n                # Check for cancellation\n                if goal_handle.is_cancel_requested:\n                    result_msg.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n                    goal_handle.canceled()\n                    self.get_logger().info(\'Motion execution canceled\')\n                    return result_msg\n                \n                # Update feedback\n                feedback_msg.desired = point\n                feedback_msg.joint_names = joint_names\n                \n                # Publish feedback\n                goal_handle.publish_feedback(feedback_msg)\n                \n                # Execute the motion while maintaining balance\n                self.execute_motion_step(point, joint_names)\n                \n                # Check if robot is still balanced\n                if not self.is_robot_balanced():\n                    result_msg.error_code = FollowJointTrajectory.Result.PATH_TOLERANCE_VIOLATED\n                    goal_handle.abort()\n                    self.get_logger().error(\'Robot lost balance during motion\')\n                    return result_msg\n                \n                self.get_logger().info(f\'Completed motion step {i+1}/{len(trajectory.points)}\')\n        finally:\n            # Stop balance control regardless of outcome\n            self.stop_balance_control()\n        \n        # Check for final cancellation\n        if goal_handle.is_cancel_requested:\n            result_msg.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n            goal_handle.canceled()\n            return result_msg\n        \n        # Success\n        result_msg.error_code = FollowJointTrajectory.Result.SUCCESSFUL\n        goal_handle.succeed()\n        self.get_logger().info(\'Motion execution completed successfully\')\n        \n        return result_msg\n\n    def is_within_joint_limits(self, joint_name, position):\n        """Check if joint position is within limits."""\n        # Implementation depends on specific robot\n        # Return True if within limits, False otherwise\n        return True\n\n    def start_balance_control(self):\n        """Start balance control system."""\n        # Implementation for humanoid balance control\n        pass\n\n    def stop_balance_control(self):\n        """Stop balance control system."""\n        # Implementation for humanoid balance control\n        pass\n\n    def is_robot_balanced(self):\n        """Check if humanoid robot is currently balanced."""\n        # Implementation for balance checking\n        # Check ZMP, joint torques, etc.\n        return True\n\n    def execute_motion_step(self, point, joint_names):\n        """Execute a single motion step."""\n        # Send position commands to joints\n        # Implementation depends on specific robot controller\n        pass\n'})}),"\n",(0,i.jsx)(n.h2,{id:"47-performance-and-reliability-considerations",children:"4.7 Performance and Reliability Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"471-resource-management",children:"4.7.1 Resource Management"}),"\n",(0,i.jsx)(n.p,{children:"Actions should manage resources carefully to avoid blocking other operations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def execute_callback(self, goal_handle):\n    # Acquire necessary resources\n    resource_acquired = self.acquire_resources()\n    if not resource_acquired:\n        result_msg = MyAction.Result()\n        result_msg.success = False\n        result_msg.message = "Could not acquire required resources"\n        goal_handle.abort()\n        return result_msg\n    \n    try:\n        # Execute the action\n        result_msg = self.perform_action_with_resources(goal_handle)\n        return result_msg\n    finally:\n        # Always release resources\n        self.release_resources()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"472-error-recovery",children:"4.7.2 Error Recovery"}),"\n",(0,i.jsx)(n.p,{children:"Implement error recovery mechanisms for complex actions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def execute_callback(self, goal_handle):\n    try:\n        # Step 1: Initialize\n        if not self.initialize_action():\n            raise RuntimeError("Failed to initialize action")\n        \n        # Step 2: Execute main operation\n        for step in self.get_execution_steps():\n            if goal_handle.is_cancel_requested:\n                return self.handle_cancel()\n            \n            try:\n                self.execute_step(step)\n            except StepExecutionError as e:\n                # Try to recover from the error\n                if self.can_recover_from_error(e):\n                    self.recover_from_error(e)\n                else:\n                    raise e  # Cannot recover, re-raise\n        \n        # Step 3: Finalize\n        return self.finalize_action()\n    \n    except Exception as e:\n        # Handle any errors that occurred\n        result_msg = MyAction.Result()\n        result_msg.success = False\n        result_msg.error_message = str(e)\n        goal_handle.abort()\n        return result_msg\n'})}),"\n",(0,i.jsx)(n.h2,{id:"48-best-practices-for-action-development",children:"4.8 Best Practices for Action Development"}),"\n",(0,i.jsx)(n.h3,{id:"481-action-interface-design",children:"4.8.1 Action Interface Design"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Define clear, specific goals that can be broken into discrete steps"}),"\n",(0,i.jsx)(n.li,{children:"Design feedback messages that provide meaningful progress information"}),"\n",(0,i.jsx)(n.li,{children:"Create result messages that clearly indicate success or failure modes"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate data types for all fields"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"482-implementation-guidelines",children:"4.8.2 Implementation Guidelines"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Always check for goal cancellation at appropriate points"}),"\n",(0,i.jsx)(n.li,{children:"Provide regular feedback during long-running operations"}),"\n",(0,i.jsx)(n.li,{children:"Implement proper error handling and recovery"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate QoS settings for action communication"}),"\n",(0,i.jsx)(n.li,{children:"Log important events for debugging and monitoring"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"483-performance-considerations",children:"4.8.3 Performance Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Minimize the size of feedback messages for high-frequency updates"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate update rates for feedback"}),"\n",(0,i.jsx)(n.li,{children:"Consider the computational complexity of your action execution"}),"\n",(0,i.jsx)(n.li,{children:"Implement efficient algorithms for processing goals"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"49-comparing-communication-patterns",children:"4.9 Comparing Communication Patterns"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"Topics"}),(0,i.jsx)(n.th,{children:"Services"}),(0,i.jsx)(n.th,{children:"Actions"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Communication Type"}),(0,i.jsx)(n.td,{children:"Async"}),(0,i.jsx)(n.td,{children:"Sync"}),(0,i.jsx)(n.td,{children:"Async (with status)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Best For"}),(0,i.jsx)(n.td,{children:"Streaming data"}),(0,i.jsx)(n.td,{children:"One-shot queries"}),(0,i.jsx)(n.td,{children:"Long-running tasks"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Blocking"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Yes (sync)"}),(0,i.jsx)(n.td,{children:"No"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Feedback"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Yes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Preemption"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsx)(n.td,{children:"Yes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Execution Time"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsx)(n.td,{children:"Short"}),(0,i.jsx)(n.td,{children:"Long"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Use Case Examples"}),(0,i.jsx)(n.td,{children:"Sensor data, robot state"}),(0,i.jsx)(n.td,{children:"Calibration, config"}),(0,i.jsx)(n.td,{children:"Navigation, manipulation"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter covered the fundamentals of action-based communication in ROS 2 for handling long-running tasks that require feedback and preemption capabilities. We explored implementation of action servers and clients, design patterns for humanoid robotics applications, and performance considerations. Actions represent a powerful communication pattern for complex robot operations that cannot be adequately handled by topics or services alone."}),"\n",(0,i.jsx)(n.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Action Server"}),"\n",(0,i.jsx)(n.li,{children:"Action Client"}),"\n",(0,i.jsx)(n.li,{children:"Goal-Feedback-Result Pattern"}),"\n",(0,i.jsx)(n.li,{children:"Action Preemption"}),"\n",(0,i.jsx)(n.li,{children:"Action Cancellation"}),"\n",(0,i.jsx)(n.li,{children:"Long-Running Tasks"}),"\n",(0,i.jsx)(n.li,{children:"Progress Feedback"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implement an action server for humanoid walking pattern generation"}),"\n",(0,i.jsx)(n.li,{children:"Create a complex action client that coordinates multiple robot subsystems"}),"\n",(0,i.jsx)(n.li,{children:"Design an action interface for whole-body motion planning"}),"\n",(0,i.jsx)(n.li,{children:"Implement error recovery mechanisms for action execution"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["ROS 2 Documentation: ",(0,i.jsx)(n.a,{href:"https://docs.ros.org/",children:"https://docs.ros.org/"})]}),"\n",(0,i.jsx)(n.li,{children:"Siciliano, B., & Khatib, O. (2016). Springer Handbook of Robotics."}),"\n",(0,i.jsx)(n.li,{children:"Fox, D., Burgard, W., & Thrun, S. (1997). The dynamic window approach to collision avoidance."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(6540);const i={},r=o.createContext(i);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);