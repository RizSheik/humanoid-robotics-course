"use strict";(globalThis.webpackChunkhumanoid_robotics_course=globalThis.webpackChunkhumanoid_robotics_course||[]).push([[5326],{2644:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2-ros-2-fundamentals/simulation","title":"Module 2: Simulation - ROS 2 Communication in Robotic Environments","description":"Simulation Overview","source":"@site/docs/module-2-ros-2-fundamentals/simulation.md","sourceDirName":"module-2-ros-2-fundamentals","slug":"/module-2-ros-2-fundamentals/simulation","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/RizSheik/humanoid-robotics-course/edit/main/docs/module-2-ros-2-fundamentals/simulation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Module 2: Practical Lab - ROS 2 Communication Patterns for Robotics","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/practical-lab"},"next":{"title":"Module 2: Assignment - ROS 2 Communication Architecture for Humanoid Robotics","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/assignment"}}');var t=i(4848),s=i(8453);const r={},l="Module 2: Simulation - ROS 2 Communication in Robotic Environments",a={},c=[{value:"Simulation Overview",id:"simulation-overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Required Simulation Tools",id:"required-simulation-tools",level:3},{value:"Simulation Environment Configuration",id:"simulation-environment-configuration",level:2},{value:"Gazebo Integration with ROS 2",id:"gazebo-integration-with-ros-2",level:3},{value:"Isaac Sim Configuration",id:"isaac-sim-configuration",level:3},{value:"Simulation 1: Topic-Based Sensor Data Streaming",id:"simulation-1-topic-based-sensor-data-streaming",level:2},{value:"Objective",id:"objective",level:3},{value:"Setup",id:"setup",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Analysis",id:"analysis",level:3},{value:"Simulation 2: Service-Based Robot Configuration and Control",id:"simulation-2-service-based-robot-configuration-and-control",level:2},{value:"Objective",id:"objective-1",level:3},{value:"Setup",id:"setup-1",level:3},{value:"Implementation",id:"implementation-1",level:3},{value:"Analysis",id:"analysis-1",level:3},{value:"Simulation 3: Action-Based Complex Task Execution",id:"simulation-3-action-based-complex-task-execution",level:2},{value:"Objective",id:"objective-2",level:3},{value:"Implementation",id:"implementation-2",level:3},{value:"Analysis",id:"analysis-2",level:3},{value:"Simulation 4: Multi-Robot Communication Simulation",id:"simulation-4-multi-robot-communication-simulation",level:2},{value:"Objective",id:"objective-3",level:3},{value:"Implementation",id:"implementation-3",level:3},{value:"Analysis",id:"analysis-3",level:3},{value:"Simulation Evaluation and Performance Metrics",id:"simulation-evaluation-and-performance-metrics",level:2},{value:"Key Performance Indicators",id:"key-performance-indicators",level:3},{value:"Measurement Tools",id:"measurement-tools",level:3},{value:"Advanced Simulation Concepts",id:"advanced-simulation-concepts",level:2},{value:"Real-time Simulation",id:"real-time-simulation",level:3},{value:"Deterministic Simulation",id:"deterministic-simulation",level:3},{value:"Simulation Troubleshooting",id:"simulation-troubleshooting",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Simulation Extensions",id:"simulation-extensions",level:2},{value:"Integration with Real Hardware in the Loop",id:"integration-with-real-hardware-in-the-loop",level:3},{value:"Cloud-Based Simulation",id:"cloud-based-simulation",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"References",id:"references",level:2}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"module-2-simulation---ros-2-communication-in-robotic-environments",children:"Module 2: Simulation - ROS 2 Communication in Robotic Environments"})}),"\n",(0,t.jsx)(n.h2,{id:"simulation-overview",children:"Simulation Overview"}),"\n",(0,t.jsx)(n.p,{children:"This simulation module focuses on implementing and testing ROS 2 communication patterns in realistic robotic environments. Students will work with simulation tools to understand how topics, services, and actions function in complex robotic systems, with particular emphasis on humanoid robot applications."}),"\n",(0,t.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"After completing this simulation module, students will be able to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Set up and configure simulation environments with ROS 2 integration"}),"\n",(0,t.jsx)(n.li,{children:"Implement and test topic-based communication for sensor data streaming"}),"\n",(0,t.jsx)(n.li,{children:"Deploy service-based systems for robot configuration and control"}),"\n",(0,t.jsx)(n.li,{children:"Execute long-running tasks using action-based communication"}),"\n",(0,t.jsx)(n.li,{children:"Analyze communication performance in simulated robotic environments"}),"\n",(0,t.jsx)(n.li,{children:"Integrate multiple communication patterns for complex robot behaviors"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"required-simulation-tools",children:"Required Simulation Tools"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gazebo Harmonic"})," or ",(0,t.jsx)(n.strong,{children:"Isaac Sim"})," for physics simulation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROS 2 Humble Hawksbill"})," for robot control and communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RViz2"})," for visualization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Python 3.11+"})," or ",(0,t.jsx)(n.strong,{children:"C++17"})," for implementing nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"rqt"})," tools for monitoring and debugging"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"rosbags2"})," for data recording and playback"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"simulation-environment-configuration",children:"Simulation Environment Configuration"}),"\n",(0,t.jsx)(n.h3,{id:"gazebo-integration-with-ros-2",children:"Gazebo Integration with ROS 2"}),"\n",(0,t.jsx)(n.p,{children:"For Gazebo-based simulations, configure the environment with proper ROS 2 bridges:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example Gazebo model configuration with ROS 2 plugins --\x3e\n<sdf version="1.7">\n  <model name="humanoid_robot">\n    \x3c!-- Robot definition --\x3e\n    <link name="base_link">\n      <sensor name="imu_sensor" type="imu">\n        <plugin filename="libignition-gazebo-imu-system.so" name="ignition::gazebo::systems::Imu">\n          <ros>\n            <namespace>/robot1</namespace>\n            <remapping>~/out@sensor_msgs/msg/Imu@ignition.msgs.IMU</remapping>\n          </ros>\n        </plugin>\n      </sensor>\n    </link>\n    \n    \x3c!-- Joint state publisher --\x3e\n    <plugin filename="libignition-gazebo-joint-state-publisher-system.so" \n            name="ignition::gazebo::systems::JointStatePublisher">\n      <ros>\n        <namespace>/robot1</namespace>\n      </ros>\n    </plugin>\n    \n    \x3c!-- Joint position controller --\x3e\n    <plugin filename="libignition-gazebo-joint-position-controller-system.so"\n            name="ignition::gazebo::systems::JointPositionController">\n      <ros>\n        <namespace>/robot1</namespace>\n      </ros>\n    </plugin>\n  </model>\n</sdf>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"isaac-sim-configuration",children:"Isaac Sim Configuration"}),"\n",(0,t.jsx)(n.p,{children:"For Isaac Sim-based simulations:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Configure the robotic platform with appropriate sensors"}),"\n",(0,t.jsx)(n.li,{children:"Set up ROS 2 bridges for each sensor type"}),"\n",(0,t.jsx)(n.li,{children:"Configure QoS settings for different data streams"}),"\n",(0,t.jsx)(n.li,{children:"Implement appropriate control interfaces"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"simulation-1-topic-based-sensor-data-streaming",children:"Simulation 1: Topic-Based Sensor Data Streaming"}),"\n",(0,t.jsx)(n.h3,{id:"objective",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Implement and test high-frequency topic-based communication for streaming sensor data in a humanoid robot simulation."}),"\n",(0,t.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Configure a humanoid robot model in simulation with multiple sensors:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"20+ joint position sensors"}),"\n",(0,t.jsx)(n.li,{children:"IMU (3-axis accelerometer, 3-axis gyroscope)"}),"\n",(0,t.jsx)(n.li,{children:"Multiple cameras (head, chest, wrist-mounted)"}),"\n",(0,t.jsx)(n.li,{children:"Force/torque sensors in feet and hands"}),"\n",(0,t.jsx)(n.li,{children:"LIDAR for environment perception"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu, Image, PointCloud2, CameraInfo\nfrom geometry_msgs.msg import Vector3\nfrom builtin_interfaces.msg import Time\nfrom cv_bridge import CvBridge\nimport numpy as np\nimport time\n\nclass RobotSensorSimulator(Node):\n    def __init__(self):\n        super().__init__('robot_sensor_simulator')\n        \n        # Create publishers for different sensor types\n        self.joint_pub = self.create_publisher(JointState, 'joint_states', 10)\n        self.imu_pub = self.create_publisher(Imu, 'imu/data', 10)\n        self.camera_pub = self.create_publisher(Image, 'camera/image_raw', 10)\n        self.camera_info_pub = self.create_publisher(CameraInfo, 'camera/camera_info', 10)\n        \n        # QoS configuration for different sensor types\n        self.sensor_qos = rclpy.qos.QoSProfile(\n            depth=5,\n            reliability=rclpy.qos.ReliabilityPolicy.BEST_EFFORT,\n            durability=rclpy.qos.DurabilityPolicy.VOLATILE\n        )\n        \n        # Publishers with specific QoS for different sensors\n        self.hf_publisher = self.create_publisher(\n            JointState, 'high_freq_sensor', self.sensor_qos)\n        \n        # CV Bridge for image processing\n        self.bridge = CvBridge()\n        \n        # Initialize joint names for humanoid robot\n        self.joint_names = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\n            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',\n            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint',\n            'neck_joint', 'waist_joint'\n        ]\n        \n        # Initialize simulation parameters\n        self.sim_time = 0.0\n        self.time_step = 0.01  # 100 Hz simulation\n        \n        # Create timers for different sensor frequencies\n        self.joint_timer = self.create_timer(0.01, self.publish_joint_states)  # 100 Hz\n        self.imu_timer = self.create_timer(0.005, self.publish_imu_data)      # 200 Hz\n        self.camera_timer = self.create_timer(0.1, self.publish_camera_data)  # 10 Hz\n        \n        self.get_logger().info('Robot sensor simulator initialized')\n\n    def publish_joint_states(self):\n        \"\"\"Publish joint state data at 100Hz.\"\"\"\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.name = self.joint_names\n        \n        # Simulate joint positions (oscillating for demonstration)\n        positions = []\n        for i, _ in enumerate(self.joint_names):\n            # Create oscillating joint positions\n            pos = 0.1 * np.sin(2 * np.pi * 0.5 * self.sim_time + i * 0.5)\n            positions.append(pos)\n        \n        msg.position = positions\n        msg.velocity = [0.0] * len(positions)  # Simplified\n        msg.effort = [0.0] * len(positions)    # Simplified\n        \n        self.joint_pub.publish(msg)\n        self.sim_time += self.time_step\n\n    def publish_imu_data(self):\n        \"\"\"Publish IMU data at 200Hz.\"\"\"\n        msg = Imu()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'imu_link'\n        \n        # Simulate IMU readings\n        msg.linear_acceleration.x = 0.1 * np.sin(2 * np.pi * 2 * self.sim_time)\n        msg.linear_acceleration.y = 0.1 * np.cos(2 * np.pi * 2 * self.sim_time)\n        msg.linear_acceleration.z = 9.8 + 0.05 * np.sin(2 * np.pi * 5 * self.sim_time)\n        \n        # Angular velocity\n        msg.angular_velocity.x = 0.5 * np.sin(2 * np.pi * 1 * self.sim_time)\n        msg.angular_velocity.y = 0.3 * np.cos(2 * np.pi * 1.5 * self.sim_time)\n        msg.angular_velocity.z = 0.2 * np.sin(2 * np.pi * 0.8 * self.sim_time)\n        \n        # Orientation (simplified)\n        msg.orientation.w = 1.0  # Perfectly upright for now\n        msg.orientation.x = 0.0\n        msg.orientation.y = 0.0\n        msg.orientation.z = 0.0\n        \n        self.imu_pub.publish(msg)\n\n    def publish_camera_data(self):\n        \"\"\"Publish camera data at 10Hz.\"\"\"\n        # Create a simple simulated image (grayscale gradient)\n        height, width = 640, 480\n        # Create a gradient image for simulation\n        img_array = np.zeros((height, width, 3), dtype=np.uint8)\n        \n        for i in range(height):\n            for j in range(width):\n                img_array[i, j, 0] = int(255 * i / height)  # Red channel gradient\n                img_array[i, j, 1] = int(255 * j / width)   # Green channel gradient\n                img_array[i, j, 2] = 128  # Constant blue\n        \n        # Convert to ROS image message\n        img_msg = self.bridge.cv2_to_imgmsg(img_array, encoding=\"bgr8\")\n        img_msg.header.stamp = self.get_clock().now().to_msg()\n        img_msg.header.frame_id = 'camera_link'\n        \n        # Publish camera info\n        info_msg = CameraInfo()\n        info_msg.header = img_msg.header\n        info_msg.width = width\n        info_msg.height = height\n        info_msg.k = [500.0, 0.0, width/2, 0.0, 500.0, height/2, 0.0, 0.0, 1.0]  # Simplified camera matrix\n        \n        self.camera_pub.publish(img_msg)\n        self.camera_info_pub.publish(info_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    sensor_simulator = RobotSensorSimulator()\n    \n    try:\n        rclpy.spin(sensor_simulator)\n    except KeyboardInterrupt:\n        sensor_simulator.get_logger().info('Simulation stopped by user')\n    finally:\n        sensor_simulator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"analysis",children:"Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Monitor topic data rates using ",(0,t.jsx)(n.code,{children:"ros2 topic hz"})]}),"\n",(0,t.jsx)(n.li,{children:"Analyze the effect of QoS settings on sensor data delivery"}),"\n",(0,t.jsx)(n.li,{children:"Test performance under different simulation loads"}),"\n",(0,t.jsx)(n.li,{children:"Visualize sensor data using RViz2"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"simulation-2-service-based-robot-configuration-and-control",children:"Simulation 2: Service-Based Robot Configuration and Control"}),"\n",(0,t.jsx)(n.h3,{id:"objective-1",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Implement and test service-based communication for robot configuration and control tasks that require synchronous responses."}),"\n",(0,t.jsx)(n.h3,{id:"setup-1",children:"Setup"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create a humanoid robot simulation with configurable parameters"}),"\n",(0,t.jsxs)(n.li,{children:["Implement services for:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Changing robot operational modes"}),"\n",(0,t.jsx)(n.li,{children:"Setting joint parameters (limits, gains)"}),"\n",(0,t.jsx)(n.li,{children:"Calibrating sensors"}),"\n",(0,t.jsx)(n.li,{children:"Emergency stop functionality"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom std_srvs.srv import Trigger, SetBool\nfrom control_msgs.srv import JointTrajectoryControllerState\nfrom sensor_msgs.msg import JointState\n\nclass RobotConfigurationSimulator(Node):\n    def __init__(self):\n        super().__init__(\'robot_config_simulator\')\n        \n        # Service servers\n        self.mode_service = self.create_service(\n            SetBool, \'set_robot_mode\', self.set_robot_mode_callback)\n        \n        self.calibration_service = self.create_service(\n            Trigger, \'calibrate_robot\', self.calibrate_robot_callback)\n        \n        self.emergency_stop_service = self.create_service(\n            Trigger, \'emergency_stop\', self.emergency_stop_callback)\n        \n        # Publisher for joint commands (for demonstration)\n        self.joint_pub = self.create_publisher(JointState, \'joint_commands\', 10)\n        \n        # Robot state\n        self.robot_mode = "idle"\n        self.calibration_status = {"completed": False, "timestamp": None}\n        self.emergency_stopped = False\n        self.joint_limits = self.initialize_joint_limits()\n        \n        self.get_logger().info(\'Robot configuration simulator initialized\')\n\n    def initialize_joint_limits(self):\n        """Initialize default joint limits for the robot."""\n        return {\n            \'left_hip_joint\': (-1.57, 1.57),   # min, max in radians\n            \'left_knee_joint\': (0.0, 2.5), \n            \'left_ankle_joint\': (-0.78, 0.78),\n            \'right_hip_joint\': (-1.57, 1.57),\n            \'right_knee_joint\': (0.0, 2.5),\n            \'right_ankle_joint\': (-0.78, 0.78),\n            # Add more joints as needed\n        }\n\n    def set_robot_mode_callback(self, request, response):\n        """Handle robot mode change requests."""\n        mode_name = "active" if request.data else "idle"\n        \n        if self.emergency_stopped and request.data:\n            response.success = False\n            response.message = "Cannot activate robot in emergency stop state"\n            self.get_logger().warn(\'Rejected activation request: robot in emergency stop\')\n            return response\n        \n        # Perform mode change\n        old_mode = self.robot_mode\n        self.robot_mode = mode_name\n        \n        # Send confirmation command to simulated robot\n        if request.data:  # Activating\n            self.activate_robot_systems()\n        else:  # Deactivating\n            self.deactivate_robot_systems()\n        \n        response.success = True\n        response.message = f"Mode changed from {old_mode} to {mode_name}"\n        \n        self.get_logger().info(f\'Robot mode changed: {old_mode} \u2192 {mode_name}\')\n        return response\n\n    def activate_robot_systems(self):\n        """Activate robot systems."""\n        # In simulation, we might enable controllers, etc.\n        self.get_logger().info(\'Activating robot systems...\')\n        # Simulate system activation\n        time.sleep(0.1)  # Simulated activation time\n\n    def deactivate_robot_systems(self):\n        """Deactivate robot systems."""\n        self.get_logger().info(\'Deactivating robot systems...\')\n        # In a real system, this would safely shut down controllers\n\n    def calibrate_robot_callback(self, request, response):\n        """Handle robot calibration requests."""\n        if self.robot_mode != "idle":\n            response.success = False\n            response.message = f"Cannot calibrate: robot is in {self.robot_mode} mode"\n            self.get_logger().warn(\'Calibration rejected: robot not in idle mode\')\n            return response\n        \n        if self.emergency_stopped:\n            response.success = False\n            response.message = "Cannot calibrate: robot in emergency stop"\n            self.get_logger().warn(\'Calibration rejected: robot in emergency stop\')\n            return response\n        \n        try:\n            # Simulate calibration process\n            self.get_logger().info(\'Starting robot calibration...\')\n            \n            # Simulate calibration steps\n            for step in range(5):\n                self.get_logger().info(f\'Calibration step {step + 1}/5\')\n                time.sleep(0.2)  # Simulate calibration time\n            \n            # Update calibration status\n            self.calibration_status = {\n                "completed": True,\n                "timestamp": self.get_clock().now().to_msg()\n            }\n            \n            response.success = True\n            response.message = "Calibration completed successfully"\n            \n            self.get_logger().info(\'Robot calibration completed\')\n            \n        except Exception as e:\n            response.success = False\n            response.message = f"Calibration failed: {str(e)}"\n            self.get_logger().error(f\'Calibration error: {str(e)}\')\n        \n        return response\n\n    def emergency_stop_callback(self, request, response):\n        """Handle emergency stop requests."""\n        if self.emergency_stopped:\n            response.success = True\n            response.message = "Robot already in emergency stop"\n            return response\n        \n        try:\n            # Execute emergency stop procedure\n            self.execute_emergency_stop()\n            \n            response.success = True\n            response.message = "Emergency stop executed successfully"\n            self.get_logger().warn(\'EMERGENCY STOP ACTIVATED\')\n            \n        except Exception as e:\n            self.get_logger().error(f\'Error during emergency stop: {str(e)}\')\n            response.success = False\n            response.message = f\'Emergency stop failed: {str(e)}\'\n        \n        return response\n\n    def execute_emergency_stop(self):\n        """Execute the actual emergency stop procedure."""\n        # Stop all joint movements immediately\n        stop_msg = JointState()\n        stop_msg.name = list(self.joint_limits.keys())\n        stop_msg.position = [0.0] * len(stop_msg.name)  # Stop at current position\n        self.joint_pub.publish(stop_msg)\n        \n        # Update robot state\n        self.emergency_stopped = True\n        self.robot_mode = "emergency"\n        \n        # Log the event\n        self.get_logger().warn(\'All joint movements stopped by emergency stop\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    config_simulator = RobotConfigurationSimulator()\n    \n    try:\n        rclpy.spin(config_simulator)\n    except KeyboardInterrupt:\n        config_simulator.get_logger().info(\'Simulation stopped by user\')\n    finally:\n        config_simulator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    import time  # Required for the implementation above\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"analysis-1",children:"Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Test service response times under different simulation loads"}),"\n",(0,t.jsx)(n.li,{children:"Evaluate reliability of service-based communication"}),"\n",(0,t.jsx)(n.li,{children:"Analyze behavior during error conditions"}),"\n",(0,t.jsx)(n.li,{children:"Test concurrent service requests"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"simulation-3-action-based-complex-task-execution",children:"Simulation 3: Action-Based Complex Task Execution"}),"\n",(0,t.jsx)(n.h3,{id:"objective-2",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Implement and test action-based communication for long-running tasks that require feedback and cancellation, such as humanoid walking or manipulation."}),"\n",(0,t.jsx)(n.h3,{id:"implementation-2",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport time\nimport rclpy\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.node import Node\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\n\nclass HumanoidMotionSimulator(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_motion_simulator\')\n        \n        # Create action server\n        self._action_server = ActionServer(\n            self,\n            FollowJointTrajectory,\n            \'humanoid_controller/follow_joint_trajectory\',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback)\n        \n        # Publisher for joint commands\n        self.joint_cmd_pub = self.create_publisher(\n            JointTrajectoryPoint, \'simulated_joint_commands\', 10)\n        \n        # Balance controller publisher\n        self.balance_cmd_pub = self.create_publisher(\n            JointTrajectoryPoint, \'balance_control_commands\', 10)\n        \n        self.get_logger().info(\'Humanoid motion simulator initialized\')\n\n    def goal_callback(self, goal_request):\n        """Accept or reject goal requests."""\n        trajectory = goal_request.trajectory\n        \n        # Validate trajectory\n        if len(trajectory.points) == 0:\n            self.get_logger().warn(\'Goal rejected: No trajectory points\')\n            return GoalResponse.REJECT\n        \n        if len(trajectory.joint_names) == 0:\n            self.get_logger().warn(\'Goal rejected: No joint names specified\')\n            return GoalResponse.REJECT\n        \n        # Check joint validity (in a real system, compare with robot\'s joints)\n        required_joints = set(trajectory.joint_names)\n        if len(required_joints) == 0:\n            return GoalResponse.REJECT\n        \n        self.get_logger().info(f\'Goal accepted with {len(trajectory.points)} points\')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        """Accept cancellation requests."""\n        self.get_logger().info(\'Received cancel request\')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        """Execute the motion goal."""\n        self.get_logger().info(\'Executing motion goal\')\n        \n        # Initialize feedback\n        feedback_msg = FollowJointTrajectory.Feedback()\n        feedback_msg.joint_names = goal_handle.request.trajectory.joint_names\n        result_msg = FollowJointTrajectory.Result()\n        \n        # Get trajectory from goal\n        trajectory = goal_handle.request.trajectory\n        joint_names = trajectory.joint_names\n        points = trajectory.points\n        \n        # Initialize feedback message\n        feedback_msg.desired = JointTrajectoryPoint()\n        feedback_msg.actual = JointTrajectoryPoint()\n        feedback_msg.error = JointTrajectoryPoint()\n        \n        # Start balance control for humanoid motion\n        self.start_balance_control()\n        \n        try:\n            # Execute trajectory point by point\n            for i, point in enumerate(points):\n                # Check for cancellation\n                if goal_handle.is_cancel_requested:\n                    self.get_logger().info(\'Motion execution canceled\')\n                    result_msg.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n                    goal_handle.canceled()\n                    return result_msg\n                \n                # Update feedback\n                feedback_msg.desired = point\n                feedback_msg.actual.positions = [0.0] * len(joint_names)\n                feedback_msg.error.positions = [0.0] * len(joint_names)\n                \n                # Calculate progress percentage\n                progress = (i + 1) / len(points) * 100.0\n                feedback_msg.progress = progress\n                \n                # Publish feedback\n                goal_handle.publish_feedback(feedback_msg)\n                \n                # Execute the motion point\n                self.execute_trajectory_point(point, joint_names)\n                \n                # Log progress\n                self.get_logger().info(f\'Progress: {progress:.1f}% ({i+1}/{len(points)})\')\n                \n                # Simulate execution time based on time_from_start\n                if i > 0:\n                    prev_point_time = points[i-1].time_from_start.sec + points[i-1].time_from_start.nanosec / 1e9\n                    curr_point_time = point.time_from_start.sec + point.time_from_start.nanosec / 1e9\n                    sleep_time = max(0, curr_point_time - prev_point_time)\n                    time.sleep(sleep_time)\n                else:\n                    time.sleep(0.01)  # Small delay for first point\n        \n        except Exception as e:\n            self.get_logger().error(f\'Error during motion execution: {str(e)}\')\n            result_msg.error_code = FollowJointTrajectory.Result.GOAL_TOLERANCE_VIOLATED\n            goal_handle.abort()\n            return result_msg\n            \n        finally:\n            # Stop balance control regardless of outcome\n            self.stop_balance_control()\n        \n        # Check for final cancellation\n        if goal_handle.is_cancel_requested:\n            result_msg.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n            goal_handle.canceled()\n            return result_msg\n        \n        # Set result and succeed\n        result_msg.error_code = FollowJointTrajectory.Result.SUCCESSFUL\n        goal_handle.succeed()\n        self.get_logger().info(\'Motion execution completed successfully\')\n        \n        return result_msg\n\n    def execute_trajectory_point(self, point, joint_names):\n        """Execute a single trajectory point."""\n        # Create and publish joint command\n        cmd_msg = JointTrajectoryPoint()\n        cmd_msg.positions = point.positions\n        cmd_msg.velocities = point.velocities if point.velocities else [0.0] * len(point.positions)\n        cmd_msg.accelerations = point.accelerations if point.accelerations else [0.0] * len(point.positions)\n        \n        # Set execution time\n        cmd_msg.time_from_start = Duration(sec=0, nanosec=int(10000000))  # 10ms\n        \n        # Publish command to simulation\n        self.joint_cmd_pub.publish(cmd_msg)\n        \n        # In a real implementation, this would interface with the robot controller\n        # and potentially adjust based on sensor feedback\n\n    def start_balance_control(self):\n        """Start balance control for humanoid motion."""\n        # In a real robot, this would start the balance controller\n        self.get_logger().info("Balance control started for humanoid motion")\n\n    def stop_balance_control(self):\n        """Stop balance control after motion."""\n        # In a real robot, this would stop the balance controller\n        self.get_logger().info("Balance control stopped after motion")\n\ndef main(args=None):\n    rclpy.init(args=args)\n    motion_simulator = HumanoidMotionSimulator()\n    \n    try:\n        rclpy.spin(motion_simulator)\n    except KeyboardInterrupt:\n        motion_simulator.get_logger().info(\'Simulation stopped by user\')\n    finally:\n        motion_simulator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"analysis-2",children:"Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Measure action execution performance and feedback frequency"}),"\n",(0,t.jsx)(n.li,{children:"Test cancellation and preemption functionality"}),"\n",(0,t.jsx)(n.li,{children:"Evaluate the effectiveness of progress reporting"}),"\n",(0,t.jsx)(n.li,{children:"Analyze communication overhead for long-running tasks"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"simulation-4-multi-robot-communication-simulation",children:"Simulation 4: Multi-Robot Communication Simulation"}),"\n",(0,t.jsx)(n.h3,{id:"objective-3",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Simulate a multi-robot environment where ROS 2 communication patterns are used for coordination and collaboration between humanoid robots."}),"\n",(0,t.jsx)(n.h3,{id:"implementation-3",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import PoseStamped\nfrom sensor_msgs.msg import JointState\nfrom rclpy.qos import QoSProfile, DurabilityPolicy, HistoryPolicy\nfrom rcl_interfaces.msg import ParameterEvent\n\nclass MultiRobotCoordinatorSimulator(Node):\n    def __init__(self):\n        super().__init__('multirobot_coordinator_sim')\n        \n        # Robot ID for this instance (passed as parameter)\n        self.declare_parameter('robot_id', 'robot1')\n        self.robot_id = self.get_parameter('robot_id').get_parameter_value().string_value\n        \n        # Create namespaced topics for multi-robot communication\n        self.status_pub = self.create_publisher(\n            String, f'/{self.robot_id}/status', 10)\n        \n        self.pose_pub = self.create_publisher(\n            PoseStamped, f'/{self.robot_id}/pose', 10)\n        \n        # Subscription to other robots' poses\n        self.other_poses_sub = self.create_subscription(\n            PoseStamped, '/other_robot/pose', self.other_pose_callback, 10)\n        \n        # Latched topic for robot status using TRANSIENT_LOCAL durability\n        latched_qos = QoSProfile(\n            depth=1,\n            durability=DurabilityPolicy.TRANSIENT_LOCAL,\n            history=HistoryPolicy.KEEP_LAST\n        )\n        self.status_latched_pub = self.create_publisher(\n            String, f'/{self.robot_id}/init_status', latched_qos)\n        \n        # Timer for status updates\n        self.status_timer = self.create_timer(1.0, self.publish_status)\n        \n        # Robot state\n        self.current_pose = PoseStamped()\n        self.other_robot_pose = None\n        self.status = \"idle\"\n        \n        # Publish initial status as latched message\n        init_status_msg = String()\n        init_status_msg.data = f\"{self.robot_id} initialized and ready\"\n        self.status_latched_pub.publish(init_status_msg)\n        \n        self.get_logger().info(f'Multi-robot coordinator for {self.robot_id} initialized')\n\n    def publish_status(self):\n        \"\"\"Publish robot status periodically.\"\"\"\n        status_msg = String()\n        status_msg.data = f\"{self.robot_id}: {self.status}\"\n        self.status_pub.publish(status_msg)\n        \n        # Also publish pose\n        self.current_pose.header.stamp = self.get_clock().now().to_msg()\n        self.current_pose.header.frame_id = 'map'\n        # Simulate movement\n        self.current_pose.pose.position.x = 1.0 * abs(hash(self.robot_id)) % 10 / 10.0\n        self.current_pose.pose.position.y = 2.0 * abs(hash(self.robot_id)) % 10 / 10.0\n        self.current_pose.pose.position.z = 0.0\n        self.pose_pub.publish(self.current_pose)\n\n    def other_pose_callback(self, msg):\n        \"\"\"Handle pose messages from other robots.\"\"\"\n        self.other_robot_pose = msg\n        self.get_logger().debug(f'Received pose from another robot at: ({msg.pose.position.x}, {msg.pose.position.y})')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    coordinator = MultiRobotCoordinatorSimulator()\n    \n    try:\n        rclpy.spin(coordinator)\n    except KeyboardInterrupt:\n        coordinator.get_logger().info('Multi-robot simulation stopped by user')\n    finally:\n        coordinator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"analysis-3",children:"Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Evaluate performance of multi-robot communication"}),"\n",(0,t.jsx)(n.li,{children:"Analyze namespace management and topic organization"}),"\n",(0,t.jsx)(n.li,{children:"Test scalability with increasing number of robots"}),"\n",(0,t.jsx)(n.li,{children:"Measure communication overhead in multi-robot systems"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"simulation-evaluation-and-performance-metrics",children:"Simulation Evaluation and Performance Metrics"}),"\n",(0,t.jsx)(n.h3,{id:"key-performance-indicators",children:"Key Performance Indicators"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Communication Latency"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Message publishing-to-receiving latency"}),"\n",(0,t.jsx)(n.li,{children:"Service response times"}),"\n",(0,t.jsx)(n.li,{children:"Action goal-to-result times"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Throughput"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Messages per second for different topics"}),"\n",(0,t.jsx)(n.li,{children:"Bandwidth utilization"}),"\n",(0,t.jsx)(n.li,{children:"CPU and memory usage"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reliability"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Message delivery rates"}),"\n",(0,t.jsx)(n.li,{children:"Error rates under load"}),"\n",(0,t.jsx)(n.li,{children:"Recovery from communication failures"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"measurement-tools",children:"Measurement Tools"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ros2 topic hz"}),": Measure message frequency"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ros2 topic delay"}),": Measure message delay"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"rqt_plot"}),": Visualize numeric data over time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ros2 bag"}),": Record data for offline analysis"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Custom monitoring nodes"}),": Track specific metrics"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"advanced-simulation-concepts",children:"Advanced Simulation Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"real-time-simulation",children:"Real-time Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Configure simulation for real-time performance with ROS 2:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Configuration for real-time simulation\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\n\n# Define real-time QoS profile\nrt_qos = QoSProfile(\n    depth=1,\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.VOLATILE,\n    deadline=Duration(seconds=0, nanoseconds=10000000)  # 10ms deadline\n)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"deterministic-simulation",children:"Deterministic Simulation"}),"\n",(0,t.jsx)(n.p,{children:"For testing and verification, create deterministic simulations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import random\n\nclass DeterministicSimulator(Node):\n    def __init__(self):\n        super().__init__('deterministic_sim')\n        # Set random seed for reproducible results\n        random.seed(42)\n        # All random operations will now be deterministic\n"})}),"\n",(0,t.jsx)(n.h2,{id:"simulation-troubleshooting",children:"Simulation Troubleshooting"}),"\n",(0,t.jsx)(n.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Topic Connection Problems"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"ros2 topic list"})," and ",(0,t.jsx)(n.code,{children:"ros2 node info"})," to verify connections"]}),"\n",(0,t.jsx)(n.li,{children:"Check ROS_DOMAIN_ID if running multiple systems"}),"\n",(0,t.jsx)(n.li,{children:"Verify QoS compatibility between publishers and subscribers"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Performance Bottlenecks"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Monitor CPU and memory usage with system tools"}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"ros2 topic hz"})," to check topic frequencies"]}),"\n",(0,t.jsxs)(n.li,{children:["Profile nodes using ",(0,t.jsx)(n.code,{children:"tracetools"})," or similar tools"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Timing Issues"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ensure proper synchronization in multi-node systems"}),"\n",(0,t.jsx)(n.li,{children:"Use appropriate timer periods for different tasks"}),"\n",(0,t.jsx)(n.li,{children:"Check for blocking operations in callback functions"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"simulation-extensions",children:"Simulation Extensions"}),"\n",(0,t.jsx)(n.h3,{id:"integration-with-real-hardware-in-the-loop",children:"Integration with Real Hardware in the Loop"}),"\n",(0,t.jsx)(n.p,{children:"Extend simulations to include real hardware components:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hardware Abstraction Layer"}),": Interface with real sensors/actuators"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mixed Reality"}),": Combine real and simulated environments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Remote Operation"}),": Control simulated robots from real interfaces"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"cloud-based-simulation",children:"Cloud-Based Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Deploy simulations in cloud environments:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Distributed Simulation"}),": Run simulation across multiple machines"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalable Testing"}),": Test with many robots simultaneously"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Management"}),": Efficiently allocate computing resources"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,t.jsx)(n.p,{children:"This simulation module provided comprehensive hands-on experience with ROS 2 communication patterns in realistic robotic environments. Students implemented and tested topic, service, and action-based communication systems, with particular focus on humanoid robot applications. The module emphasized performance evaluation, multi-robot coordination, and best practices for simulation-based testing of robotic systems."}),"\n",(0,t.jsx)(n.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Simulation Environment Configuration"}),"\n",(0,t.jsx)(n.li,{children:"Multi-Robot Communication"}),"\n",(0,t.jsx)(n.li,{children:"Quality of Service (QoS) in Simulation"}),"\n",(0,t.jsx)(n.li,{children:"Topic-Based Streaming"}),"\n",(0,t.jsx)(n.li,{children:"Service-Based Configuration"}),"\n",(0,t.jsx)(n.li,{children:"Action-Based Execution"}),"\n",(0,t.jsx)(n.li,{children:"Performance Metrics in Simulation"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["ROS 2 Documentation: ",(0,t.jsx)(n.a,{href:"https://docs.ros.org/",children:"https://docs.ros.org/"})]}),"\n",(0,t.jsxs)(n.li,{children:["Gazebo Documentation: ",(0,t.jsx)(n.a,{href:"http://gazebosim.org/",children:"http://gazebosim.org/"})]}),"\n",(0,t.jsxs)(n.li,{children:["NVIDIA Isaac Sim Documentation: ",(0,t.jsx)(n.a,{href:"https://docs.omniverse.nvidia.com/isaacsim/",children:"https://docs.omniverse.nvidia.com/isaacsim/"})]}),"\n",(0,t.jsx)(n.li,{children:"Siciliano, B., & Khatib, O. (2016). Springer Handbook of Robotics."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var o=i(6540);const t={},s=o.createContext(t);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);