"use strict";(globalThis.webpackChunkhumanoid_robotics_course=globalThis.webpackChunkhumanoid_robotics_course||[]).push([[3074],{1379:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1-physical-ai-foundations/chapter-3","title":"Chapter 3: Mathematical Foundations for Physical AI","description":"Learning Objectives","source":"@site/docs/module-1-physical-ai-foundations/chapter-3.md","sourceDirName":"module-1-physical-ai-foundations","slug":"/module-1-physical-ai-foundations/chapter-3","permalink":"/humanoid-robotics-course/docs/module-1-physical-ai-foundations/chapter-3","draft":false,"unlisted":false,"editUrl":"https://github.com/RizSheik/humanoid-robotics-course/edit/main/docs/module-1-physical-ai-foundations/chapter-3.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Chapter 2: Sensorimotor Learning and Control Theory","permalink":"/humanoid-robotics-course/docs/module-1-physical-ai-foundations/chapter-2"},"next":{"title":"Chapter 4: Applications of Embodied Intelligence in Robotics","permalink":"/humanoid-robotics-course/docs/module-1-physical-ai-foundations/chapter-4"}}');var a=n(4848),s=n(8453);const o={},r="Chapter 3: Mathematical Foundations for Physical AI",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"3.1 Mathematical Tools for Physical AI",id:"31-mathematical-tools-for-physical-ai",level:2},{value:"3.2 Linear Algebra in Robotics",id:"32-linear-algebra-in-robotics",level:2},{value:"3.2.1 Vector Spaces and Transformations",id:"321-vector-spaces-and-transformations",level:3},{value:"3.2.2 Rotation Matrices",id:"322-rotation-matrices",level:3},{value:"3.2.3 Homogeneous Transformations",id:"323-homogeneous-transformations",level:3},{value:"3.3 Kinematics and Dynamics",id:"33-kinematics-and-dynamics",level:2},{value:"3.3.1 Forward Kinematics",id:"331-forward-kinematics",level:3},{value:"3.3.2 Inverse Kinematics",id:"332-inverse-kinematics",level:3},{value:"3.3.3 Jacobian Matrix",id:"333-jacobian-matrix",level:3},{value:"3.3.4 Dynamics Equations",id:"334-dynamics-equations",level:3},{value:"3.4 Control Theory Mathematics",id:"34-control-theory-mathematics",level:2},{value:"3.4.1 State Space Representation",id:"341-state-space-representation",level:3},{value:"3.4.2 Linear Time-Invariant Systems",id:"342-linear-time-invariant-systems",level:3},{value:"3.4.3 Stability Analysis",id:"343-stability-analysis",level:3},{value:"3.4.4 Controllability and Observability",id:"344-controllability-and-observability",level:3},{value:"3.5 Optimization in Physical AI",id:"35-optimization-in-physical-ai",level:2},{value:"3.5.1 Gradient-Based Optimization",id:"351-gradient-based-optimization",level:3},{value:"3.5.2 Linear Quadratic Regulator (LQR)",id:"352-linear-quadratic-regulator-lqr",level:3},{value:"3.5.3 Trajectory Optimization",id:"353-trajectory-optimization",level:3},{value:"3.6 Uncertainty and Estimation",id:"36-uncertainty-and-estimation",level:2},{value:"3.6.1 State Estimation",id:"361-state-estimation",level:3},{value:"3.6.2 Probability in Robotics",id:"362-probability-in-robotics",level:3},{value:"3.7 Mathematical Modeling of Humanoid Systems",id:"37-mathematical-modeling-of-humanoid-systems",level:2},{value:"3.7.1 Zero Moment Point (ZMP)",id:"371-zero-moment-point-zmp",level:3},{value:"3.7.2 Linear Inverted Pendulum Model (LIPM)",id:"372-linear-inverted-pendulum-model-lipm",level:3},{value:"3.8 Practical Implementation Tips",id:"38-practical-implementation-tips",level:2},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"chapter-3-mathematical-foundations-for-physical-ai",children:"Chapter 3: Mathematical Foundations for Physical AI"})}),"\n",(0,a.jsx)(i.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(i.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Apply mathematical concepts to model physical systems"}),"\n",(0,a.jsx)(i.li,{children:"Understand the mathematics of motion and control"}),"\n",(0,a.jsx)(i.li,{children:"Analyze stability and convergence of control systems"}),"\n",(0,a.jsx)(i.li,{children:"Use mathematical tools to optimize robotic behaviors"}),"\n"]}),"\n",(0,a.jsx)("div",{className:"robotDiagram",children:(0,a.jsx)("img",{src:"/static/img/book-image/Leonardo_Lightning_XL_Mathematical_Foundations_for_Physical_AI_1.jpg",alt:"Humanoid Robot",style:{borderRadius:"50px",width:"900px",height:"350px",margin:"10px auto",display:"block"}})}),"\n",(0,a.jsx)(i.h2,{id:"31-mathematical-tools-for-physical-ai",children:"3.1 Mathematical Tools for Physical AI"}),"\n",(0,a.jsx)(i.p,{children:"Physical AI requires a solid mathematical foundation to model, analyze, and control embodied systems. Unlike traditional AI that operates on abstract data, Physical AI must model the continuous, dynamic nature of physical systems."}),"\n",(0,a.jsx)(i.p,{children:"Key mathematical tools include:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Linear algebra for transformations and state representations"}),"\n",(0,a.jsx)(i.li,{children:"Calculus for modeling continuous changes"}),"\n",(0,a.jsx)(i.li,{children:"Differential equations for system dynamics"}),"\n",(0,a.jsx)(i.li,{children:"Optimization for control and learning"}),"\n",(0,a.jsx)(i.li,{children:"Statistics and probability for dealing with uncertainty"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"32-linear-algebra-in-robotics",children:"3.2 Linear Algebra in Robotics"}),"\n",(0,a.jsx)(i.p,{children:"Linear algebra is fundamental to robotics for representing positions, orientations, and transformations."}),"\n",(0,a.jsx)(i.h3,{id:"321-vector-spaces-and-transformations",children:"3.2.1 Vector Spaces and Transformations"}),"\n",(0,a.jsx)(i.p,{children:"In robotics, we often work with vectors representing positions, velocities, and forces. For example, a position vector in 3D space is represented as:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"p = [x, y, z]^T\n"})}),"\n",(0,a.jsx)(i.h3,{id:"322-rotation-matrices",children:"3.2.2 Rotation Matrices"}),"\n",(0,a.jsx)(i.p,{children:"Rotations in 3D space are represented by 3x3 orthogonal matrices. For example, a rotation about the z-axis by angle \u03b8:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"Rz(\u03b8) = [cos(\u03b8)  -sin(\u03b8)  0]\n        [sin(\u03b8)   cos(\u03b8)  0]\n        [   0        0     1]\n"})}),"\n",(0,a.jsx)(i.h3,{id:"323-homogeneous-transformations",children:"3.2.3 Homogeneous Transformations"}),"\n",(0,a.jsx)(i.p,{children:"Homogeneous coordinates allow rotations and translations to be combined in a single 4x4 matrix:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"T = [R  p]\n    [0  1]\n"})}),"\n",(0,a.jsx)(i.p,{children:"Where R is a 3x3 rotation matrix and p is a 3x1 position vector."}),"\n",(0,a.jsx)(i.h2,{id:"33-kinematics-and-dynamics",children:"3.3 Kinematics and Dynamics"}),"\n",(0,a.jsx)(i.h3,{id:"331-forward-kinematics",children:"3.3.1 Forward Kinematics"}),"\n",(0,a.jsx)(i.p,{children:"Forward kinematics computes the end-effector position given joint angles. For a simple 2-link planar manipulator:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"x = l1*cos(\u03b81) + l2*cos(\u03b81 + \u03b82)\ny = l1*sin(\u03b81) + l2*sin(\u03b81 + \u03b82)\n"})}),"\n",(0,a.jsx)(i.h3,{id:"332-inverse-kinematics",children:"3.3.2 Inverse Kinematics"}),"\n",(0,a.jsx)(i.p,{children:"Inverse kinematics computes joint angles to achieve a desired end-effector position. This can be solved analytically for simple systems or numerically for complex multi-link systems."}),"\n",(0,a.jsx)(i.h3,{id:"333-jacobian-matrix",children:"3.3.3 Jacobian Matrix"}),"\n",(0,a.jsx)(i.p,{children:"The Jacobian relates joint velocities to end-effector velocities:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"\u1e8b = J(\u03b8) * \u03b8\u0307\n"})}),"\n",(0,a.jsx)(i.p,{children:"Where J(\u03b8) is the Jacobian matrix and \u03b8\u0307 is the vector of joint velocities."}),"\n",(0,a.jsx)(i.h3,{id:"334-dynamics-equations",children:"3.3.4 Dynamics Equations"}),"\n",(0,a.jsx)(i.p,{children:"Robot dynamics are described by the Lagrange-Euler equations or Newton-Euler formulation. For a manipulator:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"M(q)q\u0308 + C(q, q\u0307)q\u0307 + G(q) = \u03c4\n"})}),"\n",(0,a.jsx)(i.p,{children:"Where:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"M(q): Mass/inertia matrix"}),"\n",(0,a.jsx)(i.li,{children:"C(q, q\u0307): Coriolis and centrifugal terms"}),"\n",(0,a.jsx)(i.li,{children:"G(q): Gravity terms"}),"\n",(0,a.jsx)(i.li,{children:"\u03c4: Joint torques"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"34-control-theory-mathematics",children:"3.4 Control Theory Mathematics"}),"\n",(0,a.jsx)(i.h3,{id:"341-state-space-representation",children:"3.4.1 State Space Representation"}),"\n",(0,a.jsx)(i.p,{children:"A system can be represented in state space form as:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"\u1e8b(t) = f(x(t), u(t), t)\ny(t) = g(x(t), u(t), t)\n"})}),"\n",(0,a.jsx)(i.p,{children:"Where x is the state vector, u is the input vector, and y is the output vector."}),"\n",(0,a.jsx)(i.h3,{id:"342-linear-time-invariant-systems",children:"3.4.2 Linear Time-Invariant Systems"}),"\n",(0,a.jsx)(i.p,{children:"For linear time-invariant (LTI) systems:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"\u1e8b = Ax + Bu\ny = Cx + Du\n"})}),"\n",(0,a.jsx)(i.h3,{id:"343-stability-analysis",children:"3.4.3 Stability Analysis"}),"\n",(0,a.jsx)(i.p,{children:"Lyapunov stability theory provides methods for analyzing system stability. A system is stable if for any \u03b5 > 0, there exists \u03b4 > 0 such that ||x(0)|| < \u03b4 implies ||x(t)|| < \u03b5 for all t \u2265 0."}),"\n",(0,a.jsx)(i.p,{children:"For linear systems, stability is determined by the eigenvalues of the A matrix: all eigenvalues must have negative real parts."}),"\n",(0,a.jsx)(i.h3,{id:"344-controllability-and-observability",children:"3.4.4 Controllability and Observability"}),"\n",(0,a.jsx)(i.p,{children:"A system is controllable if it's possible to drive the state from any initial state to any final state in finite time. It's observable if the state can be determined from the output measurements."}),"\n",(0,a.jsx)(i.p,{children:"Controllability matrix: C = [B, AB, A\xb2B, ..., A^(n-1)B]\nObservability matrix: O = [C, CA, CA\xb2, ..., CA^(n-1)]^T"}),"\n",(0,a.jsx)(i.h2,{id:"35-optimization-in-physical-ai",children:"3.5 Optimization in Physical AI"}),"\n",(0,a.jsx)(i.h3,{id:"351-gradient-based-optimization",children:"3.5.1 Gradient-Based Optimization"}),"\n",(0,a.jsx)(i.p,{children:"Many robotics problems can be formulated as optimization problems. For minimizing a cost function J(\u03b8):"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"\u03b8_{k+1} = \u03b8_k - \u03b1\u2207J(\u03b8_k)\n"})}),"\n",(0,a.jsx)(i.h3,{id:"352-linear-quadratic-regulator-lqr",children:"3.5.2 Linear Quadratic Regulator (LQR)"}),"\n",(0,a.jsx)(i.p,{children:"The LQR finds optimal control for linear systems with quadratic cost:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"J = \u222b[x^TQx + u^TRu]dt\n"})}),"\n",(0,a.jsx)(i.p,{children:"The optimal control law is: u = -Kx, where K is computed from the algebraic Riccati equation."}),"\n",(0,a.jsx)(i.h3,{id:"353-trajectory-optimization",children:"3.5.3 Trajectory Optimization"}),"\n",(0,a.jsx)(i.p,{children:"Trajectory optimization finds optimal state and control trajectories that minimize a cost function while satisfying constraints."}),"\n",(0,a.jsx)(i.h2,{id:"36-uncertainty-and-estimation",children:"3.6 Uncertainty and Estimation"}),"\n",(0,a.jsx)(i.h3,{id:"361-state-estimation",children:"3.6.1 State Estimation"}),"\n",(0,a.jsx)(i.p,{children:"Kalman filters are commonly used for state estimation in robotic systems with noisy sensors. The discrete-time Kalman filter equations are:"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.strong,{children:"Prediction:"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"x\u0302_k|k-1 = F_k * x\u0302_k-1|k-1 + B_k * u_k"}),"\n",(0,a.jsx)(i.li,{children:"P_k|k-1 = F_k * P_k-1|k-1 * F_k^T + Q_k"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.strong,{children:"Update:"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"K_k = P_k|k-1 * H_k^T * (H_k * P_k|k-1 * H_k^T + R_k)^(-1)"}),"\n",(0,a.jsx)(i.li,{children:"x\u0302_k|k = x\u0302_k|k-1 + K_k * (z_k - H_k * x\u0302_k|k-1)"}),"\n",(0,a.jsx)(i.li,{children:"P_k|k = (I - K_k * H_k) * P_k|k-1"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"362-probability-in-robotics",children:"3.6.2 Probability in Robotics"}),"\n",(0,a.jsx)(i.p,{children:"Bayesian inference is fundamental to many robotics algorithms:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"P(A|B) = P(B|A) * P(A) / P(B)\n"})}),"\n",(0,a.jsx)(i.p,{children:"This forms the basis of algorithms like the Bayes filter, which underlies the Kalman filter and particle filters."}),"\n",(0,a.jsx)(i.h2,{id:"37-mathematical-modeling-of-humanoid-systems",children:"3.7 Mathematical Modeling of Humanoid Systems"}),"\n",(0,a.jsx)(i.p,{children:"Humanoid robots present unique mathematical challenges due to their high degrees of freedom and balance requirements."}),"\n",(0,a.jsx)(i.h3,{id:"371-zero-moment-point-zmp",children:"3.7.1 Zero Moment Point (ZMP)"}),"\n",(0,a.jsx)(i.p,{children:"The ZMP is a critical concept for bipedal locomotion stability. It's the point on the ground where the net moment of the ground reaction force is zero:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"x_zmp = (\u03a3(m_i * g * x_i - m_i * \u1e8d_i)) / (\u03a3(m_i * g))\ny_zmp = (\u03a3(m_i * g * y_i - m_i * \xff_i)) / (\u03a3(m_i * g))\n"})}),"\n",(0,a.jsx)(i.h3,{id:"372-linear-inverted-pendulum-model-lipm",children:"3.7.2 Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,a.jsx)(i.p,{children:"The LIPM simplifies humanoid balance to a point mass at height h:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"\u1e8d = g/h * (x - x_zmp)\n"})}),"\n",(0,a.jsx)(i.h2,{id:"38-practical-implementation-tips",children:"3.8 Practical Implementation Tips"}),"\n",(0,a.jsx)(i.p,{children:"When implementing mathematical models in code:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Numerical Stability"}),": Choose algorithms that are numerically stable"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Computational Efficiency"}),": Optimize for real-time performance where needed"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Coordinate Frame Consistency"}),": Maintain consistent coordinate frame definitions"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Unit Consistency"}),": Always verify units in equations and code"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,a.jsx)(i.p,{children:"This chapter provided the mathematical foundations necessary for Physical AI and robotics. We covered linear algebra, kinematics and dynamics, control theory mathematics, optimization methods, and uncertainty handling. The mathematics of humanoid systems was also discussed, particularly concepts like ZMP and LIPM that are essential for bipedal locomotion."}),"\n",(0,a.jsx)(i.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Homogeneous Transformations"}),"\n",(0,a.jsx)(i.li,{children:"Jacobian Matrix"}),"\n",(0,a.jsx)(i.li,{children:"Lyapunov Stability"}),"\n",(0,a.jsx)(i.li,{children:"Kalman Filter"}),"\n",(0,a.jsx)(i.li,{children:"Zero Moment Point (ZMP)"}),"\n",(0,a.jsx)(i.li,{children:"Linear Inverted Pendulum Model (LIPM)"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Implement forward and inverse kinematics for a 3-DOF planar manipulator"}),"\n",(0,a.jsx)(i.li,{children:"Simulate a simple control system and analyze its stability"}),"\n",(0,a.jsx)(i.li,{children:"Implement a basic Kalman filter and test it with noisy measurements"}),"\n",(0,a.jsx)(i.li,{children:"Calculate ZMP for a simple humanoid model"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Craig, J. J. (2005). Introduction to Robotics: Mechanics and Control."}),"\n",(0,a.jsx)(i.li,{children:"Spong, M. W., Hutchinson, S., & Vidyasagar, M. (2006). Robot Modeling and Control."}),"\n",(0,a.jsx)(i.li,{children:"Siciliano, B., & Khatib, O. (2016). Springer Handbook of Robotics."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>r});var t=n(6540);const a={},s=t.createContext(a);function o(e){const i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);