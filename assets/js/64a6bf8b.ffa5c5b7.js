"use strict";(globalThis.webpackChunkhumanoid_robotics_course=globalThis.webpackChunkhumanoid_robotics_course||[]).push([[6326],{8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var r=s(6540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}},8596:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"module-2-ros-2-fundamentals/chapter-3","title":"Chapter 3: Services and Synchronous Communication","description":"Learning Objectives","source":"@site/docs/module-2-ros-2-fundamentals/chapter-3.md","sourceDirName":"module-2-ros-2-fundamentals","slug":"/module-2-ros-2-fundamentals/chapter-3","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/chapter-3","draft":false,"unlisted":false,"editUrl":"https://github.com/RizSheik/humanoid-robotics-course/edit/main/docs/module-2-ros-2-fundamentals/chapter-3.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Chapter 2: Topics and Asynchronous Communication","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/chapter-2"},"next":{"title":"Chapter 4: Actions and Complex Task Execution","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/chapter-4"}}');var i=s(4848),t=s(8453);const o={},c="Chapter 3: Services and Synchronous Communication",l={},a=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"3.1 Understanding Services in ROS 2",id:"31-understanding-services-in-ros-2",level:2},{value:"3.1.1 Characteristics of Service Communication",id:"311-characteristics-of-service-communication",level:3},{value:"3.1.2 When to Use Services",id:"312-when-to-use-services",level:3},{value:"3.2 Service Types and Standard Interfaces",id:"32-service-types-and-standard-interfaces",level:2},{value:"3.2.1 Standard Service Types",id:"321-standard-service-types",level:3},{value:"3.2.2 Common Robot Service Types",id:"322-common-robot-service-types",level:3},{value:"3.2.3 Custom Service Types",id:"323-custom-service-types",level:3},{value:"3.3 Implementing Service Servers",id:"33-implementing-service-servers",level:2},{value:"3.3.1 Basic Service Server (Python)",id:"331-basic-service-server-python",level:3},{value:"3.3.2 Basic Service Server (C++)",id:"332-basic-service-server-c",level:3},{value:"3.4 Implementing Service Clients",id:"34-implementing-service-clients",level:2},{value:"3.4.1 Basic Service Client (Python)",id:"341-basic-service-client-python",level:3},{value:"3.4.2 Asynchronous Service Client (Python)",id:"342-asynchronous-service-client-python",level:3},{value:"3.5 Advanced Service Concepts",id:"35-advanced-service-concepts",level:2},{value:"3.5.1 Service with Custom Types",id:"351-service-with-custom-types",level:3},{value:"3.5.2 Batch Processing Service",id:"352-batch-processing-service",level:3},{value:"3.6 Service Design Patterns for Robotics",id:"36-service-design-patterns-for-robotics",level:2},{value:"3.6.1 Configuration Services",id:"361-configuration-services",level:3},{value:"3.6.2 Calibration Services",id:"362-calibration-services",level:3},{value:"3.6.3 State Management Services",id:"363-state-management-services",level:3},{value:"3.7 Service Implementation for Humanoid Robots",id:"37-service-implementation-for-humanoid-robots",level:2},{value:"3.7.1 Joint Control Services",id:"371-joint-control-services",level:3},{value:"3.7.2 Sensor Management Services",id:"372-sensor-management-services",level:3},{value:"3.8 Performance and Reliability Considerations",id:"38-performance-and-reliability-considerations",level:2},{value:"3.8.1 Timeout Handling",id:"381-timeout-handling",level:3},{value:"3.8.2 Error Handling and Recovery",id:"382-error-handling-and-recovery",level:3},{value:"3.9 Security Considerations",id:"39-security-considerations",level:2},{value:"3.9.1 Service Authentication",id:"391-service-authentication",level:3},{value:"3.9.2 Access Control",id:"392-access-control",level:3},{value:"3.10 Best Practices for Service Development",id:"310-best-practices-for-service-development",level:2},{value:"3.10.1 Service Naming Conventions",id:"3101-service-naming-conventions",level:3},{value:"3.10.2 Error Handling",id:"3102-error-handling",level:3},{value:"3.10.3 Performance Considerations",id:"3103-performance-considerations",level:3},{value:"3.10.4 Documentation",id:"3104-documentation",level:3},{value:"3.11 Comparison with Other Communication Patterns",id:"311-comparison-with-other-communication-patterns",level:2},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-3-services-and-synchronous-communication",children:"Chapter 3: Services and Synchronous Communication"})}),"\n",(0,i.jsx)("div",{className:"robotDiagram",children:(0,i.jsx)("img",{src:"../../../img/book-image/Flowchart_showing_ROS_2_nodes_communicat_1.jpg",alt:"Humanoid Robot",style:{borderRadius:"50px",width:"900px",height:"350px",margin:"10px auto",display:"block"}})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement service servers and clients in ROS 2"}),"\n",(0,i.jsx)(n.li,{children:"Design appropriate service interfaces for robot operations"}),"\n",(0,i.jsx)(n.li,{children:"Compare when to use services versus topics or actions"}),"\n",(0,i.jsx)(n.li,{children:"Handle synchronous communication patterns in robotic systems"}),"\n",(0,i.jsx)(n.li,{children:"Manage service request/response lifecycles"}),"\n",(0,i.jsx)(n.li,{children:"Integrate services into humanoid robot control architectures"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"31-understanding-services-in-ros-2",children:"3.1 Understanding Services in ROS 2"}),"\n",(0,i.jsx)(n.p,{children:"Services in ROS 2 implement a request-response communication pattern, which provides synchronous communication between nodes. Unlike topics, which are asynchronous and many-to-many, services are synchronous and typically one-to-one between a client and a server."}),"\n",(0,i.jsx)(n.h3,{id:"311-characteristics-of-service-communication",children:"3.1.1 Characteristics of Service Communication"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Synchronous"}),": The client waits for a response from the server"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Request-Response"}),": Client sends a request, server processes it and returns a response"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"One-to-One"}),": Typically one server handles requests from one or more clients"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Blocking"}),": The client is blocked until a response is received (unless using async clients)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"312-when-to-use-services",children:"3.1.2 When to Use Services"}),"\n",(0,i.jsx)(n.p,{children:"Services are appropriate when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You need a direct answer to a query"}),"\n",(0,i.jsx)(n.li,{children:"The operation is relatively fast (less than a few seconds)"}),"\n",(0,i.jsx)(n.li,{children:"Results are deterministic and self-contained"}),"\n",(0,i.jsx)(n.li,{children:"You need to modify robot state or configuration"}),"\n",(0,i.jsx)(n.li,{children:"You're implementing configuration or calibration operations"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Services are NOT appropriate when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The operation takes a long time to complete"}),"\n",(0,i.jsx)(n.li,{children:"The operation might be preempted"}),"\n",(0,i.jsx)(n.li,{children:"You need to send continuous feedback during execution"}),"\n",(0,i.jsx)(n.li,{children:"You're dealing with streaming data"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"32-service-types-and-standard-interfaces",children:"3.2 Service Types and Standard Interfaces"}),"\n",(0,i.jsx)(n.h3,{id:"321-standard-service-types",children:"3.2.1 Standard Service Types"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 provides standard service types in various packages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"std_srvs/srv/Empty"}),": Simple service with no parameters"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"std_srvs/srv/Trigger"}),": Returns success state, used for simple commands"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"std_srvs/srv/SetBool"}),": Set boolean value"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"std_srvs/srv/SetString"}),": Set string value"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"322-common-robot-service-types",children:"3.2.2 Common Robot Service Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"sensor_msgs/srv/SetCameraInfo"}),": Set camera calibration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"geometry_msgs/srv/GetTransform"}),": Get transformation between frames"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nav_msgs/srv/GetPlan"}),": Get path planning result"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tf2_msgs/srv/FrameGraph"}),": Get information about TF frames"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"323-custom-service-types",children:"3.2.3 Custom Service Types"}),"\n",(0,i.jsxs)(n.p,{children:["Custom services are defined using the ",(0,i.jsx)(n.code,{children:".srv"})," format with the request and response separated by ",(0,i.jsx)(n.code,{children:"---"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# Custom service: ComputeIK.srv\n# Request\ngeometry_msgs/Point target_position\ngeometry_msgs/Quaternion target_orientation\nstring chain_name\n---\n# Response\nfloat64[] joint_angles\nbool success\nstring error_message\n"})}),"\n",(0,i.jsx)(n.h2,{id:"33-implementing-service-servers",children:"3.3 Implementing Service Servers"}),"\n",(0,i.jsx)(n.h3,{id:"331-basic-service-server-python",children:"3.3.1 Basic Service Server (Python)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(SetBool, 'set_bool', self.set_bool_callback)\n\n    def set_bool_callback(self, request, response):\n        response.success = request.data\n        if request.data:\n            response.message = 'Successfully set to true'\n            self.get_logger().info('Set to true')\n        else:\n            response.message = 'Successfully set to false'\n            self.get_logger().info('Set to false')\n        \n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service = MinimalService()\n    rclpy.spin(minimal_service)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"332-basic-service-server-c",children:"3.3.2 Basic Service Server (C++)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "rclcpp/rclcpp.hpp"\n#include "std_srvs/srv/set_bool.hpp"\n\nclass MinimalService : public rclcpp::Node\n{\npublic:\n    MinimalService() : Node("minimal_service")\n    {\n        service_ = this->create_service<std_srvs::srv::SetBool>(\n            "set_bool",\n            [this](const std::shared_ptr<std_srvs::srv::SetBool::Request> request,\n                   std::shared_ptr<std_srvs::srv::SetBool::Response> response)\n            {\n                response->success = request->data;\n                if (request->data) {\n                    response->message = "Successfully set to true";\n                    RCLCPP_INFO(this->get_logger(), "Set to true");\n                } else {\n                    response->message = "Successfully set to false";\n                    RCLCPP_INFO(this->get_logger(), "Set to false");\n                }\n            });\n    }\n\nprivate:\n    rclcpp::Service<std_srvs::srv::SetBool>::SharedPtr service_;\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"34-implementing-service-clients",children:"3.4 Implementing Service Clients"}),"\n",(0,i.jsx)(n.h3,{id:"341-basic-service-client-python",children:"3.4.1 Basic Service Client (Python)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool\n\nclass MinimalClient(Node):\n    def __init__(self):\n        super().__init__('minimal_client')\n        self.cli = self.create_client(SetBool, 'set_bool')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        \n        self.req = SetBool.Request()\n\n    def send_request(self, data):\n        self.req.data = data\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_client = MinimalClient()\n    \n    # Send request\n    response = minimal_client.send_request(True)\n    minimal_client.get_logger().info(f'Result: {response.success}, {response.message}')\n    \n    minimal_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"342-asynchronous-service-client-python",children:"3.4.2 Asynchronous Service Client (Python)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom std_srvs.srv import SetBool\n\nclass AsyncMinimalClient(Node):\n    def __init__(self):\n        super().__init__('minimal_client_async')\n        self.cli = self.create_client(SetBool, 'set_bool')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        \n        self.req = SetBool.Request()\n\n    def send_request(self, data):\n        self.req.data = data\n        self.future = self.cli.call_async(self.req)\n        self.future.add_done_callback(self.response_callback)\n\n    def response_callback(self, future):\n        try:\n            response = future.result()\n            self.get_logger().info(f'Result: {response.success}, {response.message}')\n        except Exception as e:\n            self.get_logger().error(f'Service call failed: {e}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_client = AsyncMinimalClient()\n    \n    # Send request asynchronously\n    minimal_client.send_request(True)\n    \n    # Keep running to handle response callback\n    rclpy.spin(minimal_client)\n    \n    minimal_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"35-advanced-service-concepts",children:"3.5 Advanced Service Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"351-service-with-custom-types",children:"3.5.1 Service with Custom Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass CustomServiceServer(Node):\n    def __init__(self):\n        super().__init__('custom_service_server')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}')\n        self.get_logger().info(f'Sending back response: [{response.sum}]')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    service = CustomServiceServer()\n    rclpy.spin(service)\n    service.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"352-batch-processing-service",children:"3.5.2 Batch Processing Service"}),"\n",(0,i.jsx)(n.p,{children:"For services that need to process multiple items, consider design patterns that optimize performance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import Trigger  # Custom service would be better here\n\nclass BatchService(Node):\n    def __init__(self):\n        super().__init__('batch_service')\n        self.srv = self.create_service(Trigger, 'batch_process', self.batch_callback)\n\n    def batch_callback(self, request, response):\n        import time\n        # Simulate batch processing\n        time.sleep(0.5)  # Processing time\n        \n        # Perform batch operations\n        # This might involve calibration, configuration, or other bulk operations\n        success = True\n        message = \"Batch processing completed successfully\"\n        \n        response.success = success\n        response.message = message\n        return response\n"})}),"\n",(0,i.jsx)(n.h2,{id:"36-service-design-patterns-for-robotics",children:"3.6 Service Design Patterns for Robotics"}),"\n",(0,i.jsx)(n.h3,{id:"361-configuration-services",children:"3.6.1 Configuration Services"}),"\n",(0,i.jsx)(n.p,{children:"Used for setting parameters or configuration values:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# SetRobotConfiguration.srv\nstring robot_name\nfloat64[] joint_positions\nfloat64 velocity_limit\nfloat64 acceleration_limit\n---\nbool success\nstring error_message\n"})}),"\n",(0,i.jsx)(n.h3,{id:"362-calibration-services",children:"3.6.2 Calibration Services"}),"\n",(0,i.jsx)(n.p,{children:"Used for robot calibration tasks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# CalibrateSensor.srv\nstring sensor_name\nstring calibration_type\nfloat64[] calibration_parameters\n---\nbool success\nfloat64[] calculated_parameters\nstring error_message\n"})}),"\n",(0,i.jsx)(n.h3,{id:"363-state-management-services",children:"3.6.3 State Management Services"}),"\n",(0,i.jsx)(n.p,{children:"Used for changing robot operational states:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'# SetRobotState.srv\nstring requested_state  # e.g., "idle", "active", "error"\nbool force_change\n---\nbool success\nstring previous_state\nstring error_message\n'})}),"\n",(0,i.jsx)(n.h2,{id:"37-service-implementation-for-humanoid-robots",children:"3.7 Service Implementation for Humanoid Robots"}),"\n",(0,i.jsx)(n.h3,{id:"371-joint-control-services",children:"3.7.1 Joint Control Services"}),"\n",(0,i.jsx)(n.p,{children:"For setting joint positions or parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.node import Node\nfrom std_srvs.srv import Trigger\nfrom sensor_msgs.msg import JointState\n\nclass JointControlService(Node):\n    def __init__(self):\n        super().__init__('joint_control_service')\n        self.srv = self.create_service(Trigger, 'initialize_joints', self.init_joints_callback)\n        self.joint_pub = self.create_publisher(JointState, 'joint_commands', 10)\n        \n    def init_joints_callback(self, request, response):\n        # Initialize all joints to home position\n        try:\n            # Send initialization commands to joints\n            msg = JointState()\n            msg.name = ['joint1', 'joint2', 'joint3']  # Actual joint names\n            msg.position = [0.0, 0.0, 0.0]  # Home positions\n            self.joint_pub.publish(msg)\n            \n            response.success = True\n            response.message = \"Joints initialized successfully\"\n        except Exception as e:\n            response.success = False\n            response.message = f\"Failed to initialize joints: {str(e)}\"\n        \n        return response\n"})}),"\n",(0,i.jsx)(n.h3,{id:"372-sensor-management-services",children:"3.7.2 Sensor Management Services"}),"\n",(0,i.jsx)(n.p,{children:"For managing sensor states:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from std_srvs.srv import SetBool\nfrom sensor_msgs.msg import CameraInfo\n\nclass SensorManagementService(Node):\n    def __init__(self):\n        super().__init__('sensor_management_service')\n        self.enable_camera_srv = self.create_service(\n            SetBool, 'enable_camera', self.enable_camera_callback)\n        \n    def enable_camera_callback(self, request, response):\n        # Enable or disable camera based on request\n        try:\n            # Implement camera enable/disable logic\n            if request.data:\n                # Enable camera\n                self.get_logger().info(\"Camera enabled\")\n            else:\n                # Disable camera\n                self.get_logger().info(\"Camera disabled\")\n            \n            response.success = True\n            response.message = f\"Camera {'enabled' if request.data else 'disabled'} successfully\"\n        except Exception as e:\n            response.success = False\n            response.message = f\"Failed to change camera state: {str(e)}\"\n        \n        return response\n"})}),"\n",(0,i.jsx)(n.h2,{id:"38-performance-and-reliability-considerations",children:"3.8 Performance and Reliability Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"381-timeout-handling",children:"3.8.1 Timeout Handling"}),"\n",(0,i.jsx)(n.p,{children:"Implement proper timeout handling in service clients:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import Trigger\n\nclass TimeoutClient(Node):\n    def __init__(self):\n        super().__init__('timeout_client')\n        self.cli = self.create_client(Trigger, 'slow_service')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting...')\n\n    def call_with_timeout(self, timeout_sec=5.0):\n        request = Trigger.Request()\n        future = self.cli.call_async(request)\n        \n        # Wait with timeout\n        rclpy.spin_until_future_complete(self, future, timeout_sec=timeout_sec)\n        \n        if future.done():\n            try:\n                response = future.result()\n                return response\n            except Exception as e:\n                self.get_logger().error(f'Service call failed: {e}')\n                return None\n        else:\n            self.get_logger().warning('Service call timed out')\n            return None\n"})}),"\n",(0,i.jsx)(n.h3,{id:"382-error-handling-and-recovery",children:"3.8.2 Error Handling and Recovery"}),"\n",(0,i.jsx)(n.p,{children:"Implement robust error handling in service implementations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def robust_service_callback(self, request, response):\n    try:\n        # Validate input parameters\n        if not self.validate_request(request):\n            response.success = False\n            response.message = "Invalid request parameters"\n            return response\n        \n        # Perform the service operation\n        result = self.perform_operation(request)\n        \n        # Return the result\n        response.success = True\n        response.message = "Operation completed successfully"\n        # Include result data if applicable\n        response.result_data = result\n        \n    except ValueError as e:\n        # Handle value errors specifically\n        response.success = False\n        response.message = f"Value error: {str(e)}"\n    except RuntimeError as e:\n        # Handle runtime errors\n        response.success = False\n        response.message = f"Runtime error: {str(e)}"\n    except Exception as e:\n        # Handle unexpected errors\n        response.success = False\n        response.message = f"Unexpected error: {str(e)}"\n        self.get_logger().error(f"Unexpected error in service: {e}")\n    \n    return response\n'})}),"\n",(0,i.jsx)(n.h2,{id:"39-security-considerations",children:"3.9 Security Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"391-service-authentication",children:"3.9.1 Service Authentication"}),"\n",(0,i.jsx)(n.p,{children:"For security-sensitive services, consider implementing authentication mechanisms:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def secure_service_callback(self, request, response):\n    # Verify authentication token if present in request\n    if hasattr(request, 'auth_token'):\n        if not self.verify_auth_token(request.auth_token):\n            response.success = False\n            response.message = \"Authentication failed\"\n            return response\n    \n    # Perform authorized operation\n    # ... implementation ...\n    return response\n"})}),"\n",(0,i.jsx)(n.h3,{id:"392-access-control",children:"3.9.2 Access Control"}),"\n",(0,i.jsx)(n.p,{children:"Implement access control for sensitive services:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class AccessControlService(Node):\n    def __init__(self):\n        super().__init__('access_control_service')\n        # Define authorized nodes/users\n        self.authorized_nodes = ['safe_controller', 'maintenance_client']\n        self.srv = self.create_service(Trigger, 'critical_operation', self.op_callback)\n\n    def is_authorized(self, client_info):\n        # Check if client is authorized\n        # This could involve checking client node name, certificates, etc.\n        client_name = client_info.name  # hypothetical client info\n        return client_name in self.authorized_nodes\n"})}),"\n",(0,i.jsx)(n.h2,{id:"310-best-practices-for-service-development",children:"3.10 Best Practices for Service Development"}),"\n",(0,i.jsx)(n.h3,{id:"3101-service-naming-conventions",children:"3.10.1 Service Naming Conventions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use descriptive names that clearly indicate the service purpose"}),"\n",(0,i.jsxs)(n.li,{children:["Follow the pattern ",(0,i.jsx)(n.code,{children:"verb_noun"})," (e.g., ",(0,i.jsx)(n.code,{children:"enable_camera"}),", ",(0,i.jsx)(n.code,{children:"calibrate_sensor"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Use lowercase with underscores"}),"\n",(0,i.jsx)(n.li,{children:"Be consistent across related services"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3102-error-handling",children:"3.10.2 Error Handling"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Always return meaningful error messages"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate return codes to indicate different types of failures"}),"\n",(0,i.jsx)(n.li,{children:"Log errors appropriately for debugging"}),"\n",(0,i.jsx)(n.li,{children:"Implement proper cleanup in error cases"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3103-performance-considerations",children:"3.10.3 Performance Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep service operations short (under a few seconds)"}),"\n",(0,i.jsx)(n.li,{children:"For longer operations, consider using actions instead"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate QoS settings for service communication"}),"\n",(0,i.jsx)(n.li,{children:"Implement timeouts in clients to prevent hanging"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3104-documentation",children:"3.10.4 Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Document service interfaces clearly"}),"\n",(0,i.jsx)(n.li,{children:"Include examples of how to use the service"}),"\n",(0,i.jsx)(n.li,{children:"Specify expected response times"}),"\n",(0,i.jsx)(n.li,{children:"Document any dependencies or preconditions"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"311-comparison-with-other-communication-patterns",children:"3.11 Comparison with Other Communication Patterns"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"Topics"}),(0,i.jsx)(n.th,{children:"Services"}),(0,i.jsx)(n.th,{children:"Actions"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Communication Type"}),(0,i.jsx)(n.td,{children:"Async"}),(0,i.jsx)(n.td,{children:"Sync"}),(0,i.jsx)(n.td,{children:"Async (with status)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Best For"}),(0,i.jsx)(n.td,{children:"Streaming data"}),(0,i.jsx)(n.td,{children:"One-shot queries"}),(0,i.jsx)(n.td,{children:"Long-running tasks"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Blocking"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Yes (sync)"}),(0,i.jsx)(n.td,{children:"No"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Feedback"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Yes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Preemption"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsx)(n.td,{children:"Yes"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter covered the fundamentals of service-based communication in ROS 2, including implementation of service servers and clients, design patterns for robotic applications, and considerations for humanoid robot systems. We explored performance, security, and best practices for service development, emphasizing when to use services over other communication patterns."}),"\n",(0,i.jsx)(n.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Request-Response Pattern"}),"\n",(0,i.jsx)(n.li,{children:"Service Server"}),"\n",(0,i.jsx)(n.li,{children:"Service Client"}),"\n",(0,i.jsx)(n.li,{children:"Synchronous Communication"}),"\n",(0,i.jsx)(n.li,{children:"Service Interface Definition"}),"\n",(0,i.jsx)(n.li,{children:"Service Timeout"}),"\n",(0,i.jsx)(n.li,{children:"Access Control"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implement a service for calibrating robot joints"}),"\n",(0,i.jsx)(n.li,{children:"Create a service interface for emergency stop functionality"}),"\n",(0,i.jsx)(n.li,{children:"Design a service architecture for humanoid robot state management"}),"\n",(0,i.jsx)(n.li,{children:"Implement a client that handles service timeouts gracefully"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["ROS 2 Documentation: ",(0,i.jsx)(n.a,{href:"https://docs.ros.org/",children:"https://docs.ros.org/"})]}),"\n",(0,i.jsx)(n.li,{children:"Siciliano, B., & Khatib, O. (2016). Springer Handbook of Robotics."}),"\n",(0,i.jsx)(n.li,{children:"Quigley, M., Gerkey, B., & Smart, W. D. (2015). Programming robots with ROS."}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);