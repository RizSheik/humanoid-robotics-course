"use strict";(globalThis.webpackChunkhumanoid_robotics_course=globalThis.webpackChunkhumanoid_robotics_course||[]).push([[2507],{7269:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>n,toc:()=>t});const n=JSON.parse('{"id":"module-2-ros-2-fundamentals/chapter-2","title":"Chapter 2: Topics and Asynchronous Communication","description":"Learning Objectives","source":"@site/docs/module-2-ros-2-fundamentals/chapter-2.md","sourceDirName":"module-2-ros-2-fundamentals","slug":"/module-2-ros-2-fundamentals/chapter-2","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/chapter-2","draft":false,"unlisted":false,"editUrl":"https://github.com/RizSheik/humanoid-robotics-course/edit/main/docs/module-2-ros-2-fundamentals/chapter-2.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Chapter 1: Introduction to ROS 2 Architecture and Middleware","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/chapter-1"},"next":{"title":"Chapter 3: Services and Synchronous Communication","permalink":"/humanoid-robotics-course/docs/module-2-ros-2-fundamentals/chapter-3"}}');var r=i(4848),o=i(8453);const l={},a="Chapter 2: Topics and Asynchronous Communication",c={},t=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"2.1 Understanding Topics in ROS 2",id:"21-understanding-topics-in-ros-2",level:2},{value:"2.1.1 Characteristics of Topic Communication",id:"211-characteristics-of-topic-communication",level:3},{value:"2.1.2 Message Passing Flow",id:"212-message-passing-flow",level:3},{value:"2.2 Message Types and Serialization",id:"22-message-types-and-serialization",level:2},{value:"2.2.1 Standard Message Types",id:"221-standard-message-types",level:3},{value:"2.2.2 Geometry Message Types",id:"222-geometry-message-types",level:3},{value:"2.2.3 Sensor Message Types",id:"223-sensor-message-types",level:3},{value:"2.2.4 Custom Message Types",id:"224-custom-message-types",level:3},{value:"2.3 Implementing Publishers and Subscribers",id:"23-implementing-publishers-and-subscribers",level:2},{value:"2.3.1 Basic Publisher (Python)",id:"231-basic-publisher-python",level:3},{value:"2.3.2 Basic Subscriber (Python)",id:"232-basic-subscriber-python",level:3},{value:"2.3.3 Publisher and Subscriber (C++)",id:"233-publisher-and-subscriber-c",level:3},{value:"2.4 Quality of Service (QoS) Configuration",id:"24-quality-of-service-qos-configuration",level:2},{value:"2.4.1 Reliability Policy",id:"241-reliability-policy",level:3},{value:"2.4.2 Durability Policy",id:"242-durability-policy",level:3},{value:"2.4.3 History Policy",id:"243-history-policy",level:3},{value:"2.5 Advanced Topic Patterns",id:"25-advanced-topic-patterns",level:2},{value:"2.5.1 Latched Topics",id:"251-latched-topics",level:3},{value:"2.5.2 Topic Remapping",id:"252-topic-remapping",level:3},{value:"2.5.3 Topic Namespacing",id:"253-topic-namespacing",level:3},{value:"2.6 Topic Design for Humanoid Robots",id:"26-topic-design-for-humanoid-robots",level:2},{value:"2.6.1 Sensor Data Topics",id:"261-sensor-data-topics",level:3},{value:"2.6.2 Control Command Topics",id:"262-control-command-topics",level:3},{value:"2.6.3 State Information Topics",id:"263-state-information-topics",level:3},{value:"2.7 Performance Considerations",id:"27-performance-considerations",level:2},{value:"2.7.1 Message Frequency",id:"271-message-frequency",level:3},{value:"2.7.2 Message Size",id:"272-message-size",level:3},{value:"2.7.3 Resource Management",id:"273-resource-management",level:3},{value:"2.8 Debugging Topic Communication",id:"28-debugging-topic-communication",level:2},{value:"2.8.1 Common Commands",id:"281-common-commands",level:3},{value:"2.8.2 Debugging Strategies",id:"282-debugging-strategies",level:3},{value:"2.9 Best Practices for Topic Design",id:"29-best-practices-for-topic-design",level:2},{value:"2.9.1 Naming Conventions",id:"291-naming-conventions",level:3},{value:"2.9.2 Message Design",id:"292-message-design",level:3},{value:"2.9.3 Performance Optimization",id:"293-performance-optimization",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"chapter-2-topics-and-asynchronous-communication",children:"Chapter 2: Topics and Asynchronous Communication"})}),"\n",(0,r.jsx)("div",{className:"robotDiagram",children:(0,r.jsx)("img",{src:"../../../img/book-image/Leonardo_Lightning_XL_Topics_and_Asynchronous_CommunicationLea_0.jpg",alt:"Humanoid Robot",style:{borderRadius:"50px",width:"900px",height:"350px",margin:"10px auto",display:"block"}})}),"\n",(0,r.jsx)(s.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(s.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Implement publisher and subscriber nodes in ROS 2"}),"\n",(0,r.jsx)(s.li,{children:"Design appropriate message types for different robot subsystems"}),"\n",(0,r.jsx)(s.li,{children:"Configure Quality of Service (QoS) settings for various communication needs"}),"\n",(0,r.jsx)(s.li,{children:"Handle message serialization and deserialization"}),"\n",(0,r.jsx)(s.li,{children:"Debug common issues in topic-based communication"}),"\n",(0,r.jsx)(s.li,{children:"Design efficient topic architectures for humanoid robot coordination"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"21-understanding-topics-in-ros-2",children:"2.1 Understanding Topics in ROS 2"}),"\n",(0,r.jsx)(s.p,{children:"Topics in ROS 2 implement a publish-subscribe messaging pattern, which enables asynchronous communication between nodes. In this model, publisher nodes send messages to topics, while subscriber nodes receive messages from topics. This decoupling allows for flexible system design where publishers and subscribers can be developed and deployed independently."}),"\n",(0,r.jsx)(s.h3,{id:"211-characteristics-of-topic-communication",children:"2.1.1 Characteristics of Topic Communication"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Asynchronous"}),": Publishers don't wait for responses from subscribers"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Many-to-many"}),": Multiple publishers can send to a single topic; multiple subscribers can receive from a topic"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Loose coupling"}),": Publishers don't need to know about subscribers, and vice versa"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Reliable delivery"}),": With appropriate QoS settings, messages can be delivered reliably"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"212-message-passing-flow",children:"2.1.2 Message Passing Flow"}),"\n",(0,r.jsx)(s.p,{children:"The message flow in topic communication:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"Publisher node creates a message and publishes it to a topic"}),"\n",(0,r.jsx)(s.li,{children:"DDS (middleware) manages the distribution of the message to all subscribers"}),"\n",(0,r.jsx)(s.li,{children:"Subscribers receive the message in their callback functions"}),"\n",(0,r.jsx)(s.li,{children:"Each subscriber processes the message independently"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"22-message-types-and-serialization",children:"2.2 Message Types and Serialization"}),"\n",(0,r.jsx)(s.h3,{id:"221-standard-message-types",children:"2.2.1 Standard Message Types"}),"\n",(0,r.jsxs)(s.p,{children:["ROS 2 provides standard message types defined in the ",(0,r.jsx)(s.code,{children:"std_msgs"})," package:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"std_msgs/msg/String"}),": Simple string messages"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"std_msgs/msg/Int32"}),", ",(0,r.jsx)(s.code,{children:"std_msgs/msg/Float64"}),": Numeric values"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"std_msgs/msg/Bool"}),": Boolean values"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"std_msgs/msg/Header"}),": Header with timestamp and frame ID"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"222-geometry-message-types",children:"2.2.2 Geometry Message Types"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"geometry_msgs"})," package provides common robotic message types:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"geometry_msgs/msg/Twist"}),": Linear and angular velocity commands"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"geometry_msgs/msg/Pose"}),": Position and orientation"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"geometry_msgs/msg/Point"}),": 3D point"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"geometry_msgs/msg/Quaternion"}),": Rotation representation"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"geometry_msgs/msg/TransformStamped"}),": Coordinate transformations"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"223-sensor-message-types",children:"2.2.3 Sensor Message Types"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"sensor_msgs"})," package provides messages for sensor data:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"sensor_msgs/msg/JointState"}),": Joint positions, velocities, and efforts"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"sensor_msgs/msg/LaserScan"}),": LIDAR data"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"sensor_msgs/msg/Image"}),": Camera images"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"sensor_msgs/msg/Imu"}),": Inertial measurement unit data"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"sensor_msgs/msg/BatteryState"}),": Battery information"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"224-custom-message-types",children:"2.2.4 Custom Message Types"}),"\n",(0,r.jsxs)(s.p,{children:["For specialized applications, custom messages can be defined using the ",(0,r.jsx)(s.code,{children:".msg"})," format:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-txt",children:"# Custom message: RobotStatus.msg\nbool is_active\nfloat32 battery_voltage\nstring current_task\nint32 error_code\n"})}),"\n",(0,r.jsx)(s.p,{children:"Custom messages are compiled during the build process and can be used like standard message types."}),"\n",(0,r.jsx)(s.h2,{id:"23-implementing-publishers-and-subscribers",children:"2.3 Implementing Publishers and Subscribers"}),"\n",(0,r.jsx)(s.h3,{id:"231-basic-publisher-python",children:"2.3.1 Basic Publisher (Python)"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello World: {self.i}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(s.h3,{id:"232-basic-subscriber-python",children:"2.3.2 Basic Subscriber (Python)"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_subscriber = MinimalSubscriber()\n    rclpy.spin(minimal_subscriber)\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(s.h3,{id:"233-publisher-and-subscriber-c",children:"2.3.3 Publisher and Subscriber (C++)"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'// Publisher\n#include "rclcpp/rclcpp.hpp"\n#include "std_msgs/msg/string.hpp"\n\nclass MinimalPublisher : public rclcpp::Node\n{\npublic:\n    MinimalPublisher() : Node("minimal_publisher"), count_(0)\n    {\n        publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);\n        timer_ = this->create_wall_timer(\n            500ms, std::bind(&MinimalPublisher::timer_callback, this));\n    }\n\nprivate:\n    void timer_callback()\n    {\n        auto message = std_msgs::msg::String();\n        message.data = "Hello World: " + std::to_string(count_++);\n        RCLCPP_INFO(this->get_logger(), "Publishing: \'%s\'", message.data.c_str());\n        publisher_->publish(message);\n    }\n    rclcpp::TimerBase::SharedPtr timer_;\n    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;\n    size_t count_;\n};\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'// Subscriber\n#include "rclcpp/rclcpp.hpp"\n#include "std_msgs/msg/string.hpp"\n\nclass MinimalSubscriber : public rclcpp::Node\n{\npublic:\n    MinimalSubscriber() : Node("minimal_subscriber")\n    {\n        subscription_ = this->create_subscription<std_msgs::msg::String>(\n            "topic", 10,\n            [this](const std_msgs::msg::String::SharedPtr msg) {\n                RCLCPP_INFO(this->get_logger(), "I heard: \'%s\'", msg->data.c_str());\n            });\n    }\n\nprivate:\n    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;\n};\n'})}),"\n",(0,r.jsx)(s.h2,{id:"24-quality-of-service-qos-configuration",children:"2.4 Quality of Service (QoS) Configuration"}),"\n",(0,r.jsx)(s.h3,{id:"241-reliability-policy",children:"2.4.1 Reliability Policy"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy\n\n# Reliable - ensure all messages are received\nqos_profile = QoSProfile(\n    depth=10,\n    reliability=ReliabilityPolicy.RELIABLE\n)\n\n# Best effort - maximize performance over reliability\nqos_profile = QoSProfile(\n    depth=10,\n    reliability=ReliabilityPolicy.BEST_EFFORT\n)\n"})}),"\n",(0,r.jsx)(s.h3,{id:"242-durability-policy",children:"2.4.2 Durability Policy"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, DurabilityPolicy\n\n# Volatile - don't store messages for late-joining subscribers\nqos_profile = QoSProfile(\n    depth=10,\n    durability=DurabilityPolicy.VOLATILE\n)\n\n# Transient local - store messages for late-joining subscribers\nqos_profile = QoSProfile(\n    depth=10,\n    durability=DurabilityPolicy.TRANSIENT_LOCAL\n)\n"})}),"\n",(0,r.jsx)(s.h3,{id:"243-history-policy",children:"2.4.3 History Policy"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, HistoryPolicy\n\n# Keep last N messages\nqos_profile = QoSProfile(\n    depth=5,\n    history=HistoryPolicy.KEEP_LAST\n)\n\n# Keep all messages (up to limits)\nqos_profile = QoSProfile(\n    depth=5,\n    history=HistoryPolicy.KEEP_ALL\n)\n"})}),"\n",(0,r.jsx)(s.h2,{id:"25-advanced-topic-patterns",children:"2.5 Advanced Topic Patterns"}),"\n",(0,r.jsx)(s.h3,{id:"251-latched-topics",children:"2.5.1 Latched Topics"}),"\n",(0,r.jsx)(s.p,{children:"Latched topics store the last published message and send it immediately to new subscribers. This is useful for configuration data that needs to be available immediately upon connection."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, LivelinessPolicy\n\n# Create a latch-like behavior using TRANSIENT_LOCAL durability\nqos_profile = QoSProfile(\n    depth=1,\n    durability=rclpy.qos.DurabilityPolicy.TRANSIENT_LOCAL\n)\n"})}),"\n",(0,r.jsx)(s.h3,{id:"252-topic-remapping",children:"2.5.2 Topic Remapping"}),"\n",(0,r.jsx)(s.p,{children:"Topic remapping allows changing topic names without modifying source code:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"# Remap /topic to /new_topic\nros2 run package_name node_name --ros-args --remap __ns:=/robot1 --remap topic:=new_topic\n"})}),"\n",(0,r.jsx)(s.h3,{id:"253-topic-namespacing",children:"2.5.3 Topic Namespacing"}),"\n",(0,r.jsx)(s.p,{children:"Namespacing helps organize topics for multi-robot systems:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"# Create namespace for robot1\nself.publisher_ = self.create_publisher(String, 'robot1/sensor_data', 10)\n"})}),"\n",(0,r.jsx)(s.h2,{id:"26-topic-design-for-humanoid-robots",children:"2.6 Topic Design for Humanoid Robots"}),"\n",(0,r.jsx)(s.h3,{id:"261-sensor-data-topics",children:"2.6.1 Sensor Data Topics"}),"\n",(0,r.jsx)(s.p,{children:"For humanoid robots, common sensor topics include:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Joint states: ",(0,r.jsx)(s.code,{children:"joint_states"})," (sensor_msgs/JointState)"]}),"\n",(0,r.jsxs)(s.li,{children:["IMU data: ",(0,r.jsx)(s.code,{children:"imu/data"})," (sensor_msgs/Imu)"]}),"\n",(0,r.jsxs)(s.li,{children:["Camera images: ",(0,r.jsx)(s.code,{children:"camera/image_raw"})," (sensor_msgs/Image)"]}),"\n",(0,r.jsxs)(s.li,{children:["LIDAR scans: ",(0,r.jsx)(s.code,{children:"scan"})," (sensor_msgs/LaserScan)"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"262-control-command-topics",children:"2.6.2 Control Command Topics"}),"\n",(0,r.jsx)(s.p,{children:"For commanding humanoid robot subsystems:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Joint commands: ",(0,r.jsx)(s.code,{children:"joint_commands"})," (trajectory_msgs/JointTrajectory)"]}),"\n",(0,r.jsxs)(s.li,{children:["Base velocity: ",(0,r.jsx)(s.code,{children:"cmd_vel"})," (geometry_msgs/Twist)"]}),"\n",(0,r.jsxs)(s.li,{children:["Head position: ",(0,r.jsx)(s.code,{children:"head_controller/position"})," (control_msgs/JointTrajectoryControllerState)"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"263-state-information-topics",children:"2.6.3 State Information Topics"}),"\n",(0,r.jsx)(s.p,{children:"For sharing robot state across components:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Robot state: ",(0,r.jsx)(s.code,{children:"robot_state"})," (custom message with battery, status, etc.)"]}),"\n",(0,r.jsxs)(s.li,{children:["Odometry: ",(0,r.jsx)(s.code,{children:"odom"})," (nav_msgs/Odometry)"]}),"\n",(0,r.jsxs)(s.li,{children:["TF transforms: ",(0,r.jsx)(s.code,{children:"tf"})," and ",(0,r.jsx)(s.code,{children:"tf_static"})," (tf2_msgs/TFMessage)"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"27-performance-considerations",children:"2.7 Performance Considerations"}),"\n",(0,r.jsx)(s.h3,{id:"271-message-frequency",children:"2.7.1 Message Frequency"}),"\n",(0,r.jsx)(s.p,{children:"Consider the appropriate publishing frequency for your application:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"High-frequency data (IMU): 100-1000 Hz"}),"\n",(0,r.jsx)(s.li,{children:"Control commands: 50-200 Hz"}),"\n",(0,r.jsx)(s.li,{children:"State information: 1-10 Hz"}),"\n",(0,r.jsx)(s.li,{children:"Debug/status: 0.1-1 Hz"}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"272-message-size",children:"2.7.2 Message Size"}),"\n",(0,r.jsx)(s.p,{children:"Optimize message size for network efficiency:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Use appropriate data types (e.g., float32 vs float64)"}),"\n",(0,r.jsx)(s.li,{children:"Minimize string usage in high-frequency messages"}),"\n",(0,r.jsx)(s.li,{children:"Consider compression for image or point cloud data"}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"273-resource-management",children:"2.7.3 Resource Management"}),"\n",(0,r.jsx)(s.p,{children:"Manage resources properly in your nodes:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Use appropriate queue sizes based on expected message rate"}),"\n",(0,r.jsx)(s.li,{children:"Clean up resources properly when nodes shut down"}),"\n",(0,r.jsx)(s.li,{children:"Monitor CPU and memory usage during operation"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"28-debugging-topic-communication",children:"2.8 Debugging Topic Communication"}),"\n",(0,r.jsx)(s.h3,{id:"281-common-commands",children:"2.8.1 Common Commands"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"# List all topics\nros2 topic list\n\n# Get information about a specific topic\nros2 topic info /topic_name\n\n# Echo messages on a topic\nros2 topic echo /topic_name\n\n# Publish a message from command line\nros2 topic pub /topic_name std_msgs/String \"data: 'Hello'\"\n"})}),"\n",(0,r.jsx)(s.h3,{id:"282-debugging-strategies",children:"2.8.2 Debugging Strategies"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Check topic availability"}),": Use ",(0,r.jsx)(s.code,{children:"ros2 topic list"})," to verify topics exist"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Monitor message flow"}),": Use ",(0,r.jsx)(s.code,{children:"ros2 topic echo"})," to see if messages are being published"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Verify node connections"}),": Use ",(0,r.jsx)(s.code,{children:"ros2 node info <node_name>"})," to check subscriptions/publishers"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Check QoS compatibility"}),": Ensure publishers and subscribers have compatible QoS settings"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Monitor system resources"}),": Check for CPU/memory issues that might affect performance"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"29-best-practices-for-topic-design",children:"2.9 Best Practices for Topic Design"}),"\n",(0,r.jsx)(s.h3,{id:"291-naming-conventions",children:"2.9.1 Naming Conventions"}),"\n",(0,r.jsx)(s.p,{children:"Follow consistent naming conventions:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Use lowercase with underscores: ",(0,r.jsx)(s.code,{children:"sensor_data"}),", ",(0,r.jsx)(s.code,{children:"joint_states"})]}),"\n",(0,r.jsxs)(s.li,{children:["Group related topics with prefixes: ",(0,r.jsx)(s.code,{children:"head_camera/image_raw"}),", ",(0,r.jsx)(s.code,{children:"head_camera/camera_info"})]}),"\n",(0,r.jsx)(s.li,{children:"Use descriptive names that indicate content and purpose"}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"292-message-design",children:"2.9.2 Message Design"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Keep messages focused and specific"}),"\n",(0,r.jsx)(s.li,{children:"Use existing message types when possible"}),"\n",(0,r.jsx)(s.li,{children:"Include necessary metadata (timestamps, source information)"}),"\n",(0,r.jsx)(s.li,{children:"Consider extensibility for future requirements"}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"293-performance-optimization",children:"2.9.3 Performance Optimization"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Use appropriate QoS settings for your application"}),"\n",(0,r.jsx)(s.li,{children:"Consider message frequency and system load"}),"\n",(0,r.jsx)(s.li,{children:"Monitor and optimize for minimal latency"}),"\n",(0,r.jsx)(s.li,{children:"Implement appropriate buffering strategies"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,r.jsx)(s.p,{children:"This chapter covered the fundamentals of topic-based communication in ROS 2, including implementation of publishers and subscribers, message types, QoS configuration, and design patterns for humanoid robotics applications. We explored performance considerations and debugging techniques for topic communication, emphasizing best practices for reliable, efficient robotic systems."}),"\n",(0,r.jsx)(s.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Publish-Subscribe Pattern"}),"\n",(0,r.jsx)(s.li,{children:"Message Serialization"}),"\n",(0,r.jsx)(s.li,{children:"Quality of Service (QoS)"}),"\n",(0,r.jsx)(s.li,{children:"Latched Topics"}),"\n",(0,r.jsx)(s.li,{children:"Topic Remapping"}),"\n",(0,r.jsx)(s.li,{children:"Namespacing"}),"\n",(0,r.jsx)(s.li,{children:"Message Frequency"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"Implement a publisher-subscriber pair that shares robot sensor data"}),"\n",(0,r.jsx)(s.li,{children:"Configure different QoS profiles for various types of sensor data"}),"\n",(0,r.jsx)(s.li,{children:"Design a topic architecture for a humanoid robot with 20+ joints"}),"\n",(0,r.jsx)(s.li,{children:"Debug a simulated communication problem between two nodes"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["ROS 2 Documentation: ",(0,r.jsx)(s.a,{href:"https://docs.ros.org/",children:"https://docs.ros.org/"})]}),"\n",(0,r.jsxs)(s.li,{children:["DDS Specification: ",(0,r.jsx)(s.a,{href:"https://www.omg.org/spec/DDS/",children:"https://www.omg.org/spec/DDS/"})]}),"\n",(0,r.jsx)(s.li,{children:"Siciliano, B., & Khatib, O. (2016). Springer Handbook of Robotics."}),"\n"]})]})}function m(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,s,i)=>{i.d(s,{R:()=>l,x:()=>a});var n=i(6540);const r={},o=n.createContext(r);function l(e){const s=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);