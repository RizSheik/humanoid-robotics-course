<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-module-1-physical-ai-foundations/chapter-3" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">Chapter 3: Mathematical Foundations for Physical AI | Physical AI &amp; Humanoid Robotics — AI Systems in the Physical World</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://rizsheik.github.io/humanoid-robotics-course/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://rizsheik.github.io/humanoid-robotics-course/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://rizsheik.github.io/humanoid-robotics-course/docs/module-1-physical-ai-foundations/chapter-3"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Chapter 3: Mathematical Foundations for Physical AI | Physical AI &amp; Humanoid Robotics — AI Systems in the Physical World"><meta data-rh="true" name="description" content="Learning Objectives"><meta data-rh="true" property="og:description" content="Learning Objectives"><link data-rh="true" rel="icon" href="/humanoid-robotics-course/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://rizsheik.github.io/humanoid-robotics-course/docs/module-1-physical-ai-foundations/chapter-3"><link data-rh="true" rel="alternate" href="https://rizsheik.github.io/humanoid-robotics-course/docs/module-1-physical-ai-foundations/chapter-3" hreflang="en"><link data-rh="true" rel="alternate" href="https://rizsheik.github.io/humanoid-robotics-course/docs/module-1-physical-ai-foundations/chapter-3" hreflang="x-default"><link rel="stylesheet" href="/humanoid-robotics-course/assets/css/styles.50e26d9c.css">
<script src="/humanoid-robotics-course/assets/js/runtime~main.29b207dd.js" defer="defer"></script>
<script src="/humanoid-robotics-course/assets/js/main.b8200acf.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/humanoid-robotics-course/img/robot-head.svg"><link rel="preload" as="image" href="../../../img/book-image/Leonardo_Lightning_XL_Mathematical_Foundations_for_Physical_AI_1.jpg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/humanoid-robotics-course/"><div class="navbar__logo"><img src="/humanoid-robotics-course/img/robot-head.svg" alt="Humanoid Robotics Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/humanoid-robotics-course/img/robot-head.svg" alt="Humanoid Robotics Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Physical AI &amp; Humanoid Robotics</b></a><a class="navbar__item navbar__link" href="/humanoid-robotics-course/docs/intro">Textbook Modules</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/RizSheik/humanoid-robotics-course" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><main class="docMainContainer_TBSr docMainContainerEnhanced_lQrH"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Chapter 3: Mathematical Foundations for Physical AI</h1></header>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="learning-objectives">Learning Objectives<a href="#learning-objectives" class="hash-link" aria-label="Direct link to Learning Objectives" title="Direct link to Learning Objectives" translate="no">​</a></h2>
<p>After completing this chapter, students will be able to:</p>
<ul>
<li class="">Apply mathematical concepts to model physical systems</li>
<li class="">Understand the mathematics of motion and control</li>
<li class="">Analyze stability and convergence of control systems</li>
<li class="">Use mathematical tools to optimize robotic behaviors</li>
</ul>
<div class="robotDiagram"><img src="../../../img/book-image/Leonardo_Lightning_XL_Mathematical_Foundations_for_Physical_AI_1.jpg" alt="Humanoid Robot" style="border-radius:50px;width:900px;height:350px;margin:10px auto;display:block"></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="31-mathematical-tools-for-physical-ai">3.1 Mathematical Tools for Physical AI<a href="#31-mathematical-tools-for-physical-ai" class="hash-link" aria-label="Direct link to 3.1 Mathematical Tools for Physical AI" title="Direct link to 3.1 Mathematical Tools for Physical AI" translate="no">​</a></h2>
<p>Physical AI requires a solid mathematical foundation to model, analyze, and control embodied systems. Unlike traditional AI that operates on abstract data, Physical AI must model the continuous, dynamic nature of physical systems.</p>
<p>Key mathematical tools include:</p>
<ul>
<li class="">Linear algebra for transformations and state representations</li>
<li class="">Calculus for modeling continuous changes</li>
<li class="">Differential equations for system dynamics</li>
<li class="">Optimization for control and learning</li>
<li class="">Statistics and probability for dealing with uncertainty</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="32-linear-algebra-in-robotics">3.2 Linear Algebra in Robotics<a href="#32-linear-algebra-in-robotics" class="hash-link" aria-label="Direct link to 3.2 Linear Algebra in Robotics" title="Direct link to 3.2 Linear Algebra in Robotics" translate="no">​</a></h2>
<p>Linear algebra is fundamental to robotics for representing positions, orientations, and transformations.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="321-vector-spaces-and-transformations">3.2.1 Vector Spaces and Transformations<a href="#321-vector-spaces-and-transformations" class="hash-link" aria-label="Direct link to 3.2.1 Vector Spaces and Transformations" title="Direct link to 3.2.1 Vector Spaces and Transformations" translate="no">​</a></h3>
<p>In robotics, we often work with vectors representing positions, velocities, and forces. For example, a position vector in 3D space is represented as:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">p = [x, y, z]^T</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="322-rotation-matrices">3.2.2 Rotation Matrices<a href="#322-rotation-matrices" class="hash-link" aria-label="Direct link to 3.2.2 Rotation Matrices" title="Direct link to 3.2.2 Rotation Matrices" translate="no">​</a></h3>
<p>Rotations in 3D space are represented by 3x3 orthogonal matrices. For example, a rotation about the z-axis by angle θ:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Rz(θ) = [cos(θ)  -sin(θ)  0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [sin(θ)   cos(θ)  0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        [   0        0     1]</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="323-homogeneous-transformations">3.2.3 Homogeneous Transformations<a href="#323-homogeneous-transformations" class="hash-link" aria-label="Direct link to 3.2.3 Homogeneous Transformations" title="Direct link to 3.2.3 Homogeneous Transformations" translate="no">​</a></h3>
<p>Homogeneous coordinates allow rotations and translations to be combined in a single 4x4 matrix:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">T = [R  p]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [0  1]</span><br></span></code></pre></div></div>
<p>Where R is a 3x3 rotation matrix and p is a 3x1 position vector.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="33-kinematics-and-dynamics">3.3 Kinematics and Dynamics<a href="#33-kinematics-and-dynamics" class="hash-link" aria-label="Direct link to 3.3 Kinematics and Dynamics" title="Direct link to 3.3 Kinematics and Dynamics" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="331-forward-kinematics">3.3.1 Forward Kinematics<a href="#331-forward-kinematics" class="hash-link" aria-label="Direct link to 3.3.1 Forward Kinematics" title="Direct link to 3.3.1 Forward Kinematics" translate="no">​</a></h3>
<p>Forward kinematics computes the end-effector position given joint angles. For a simple 2-link planar manipulator:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">x = l1*cos(θ1) + l2*cos(θ1 + θ2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">y = l1*sin(θ1) + l2*sin(θ1 + θ2)</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="332-inverse-kinematics">3.3.2 Inverse Kinematics<a href="#332-inverse-kinematics" class="hash-link" aria-label="Direct link to 3.3.2 Inverse Kinematics" title="Direct link to 3.3.2 Inverse Kinematics" translate="no">​</a></h3>
<p>Inverse kinematics computes joint angles to achieve a desired end-effector position. This can be solved analytically for simple systems or numerically for complex multi-link systems.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="333-jacobian-matrix">3.3.3 Jacobian Matrix<a href="#333-jacobian-matrix" class="hash-link" aria-label="Direct link to 3.3.3 Jacobian Matrix" title="Direct link to 3.3.3 Jacobian Matrix" translate="no">​</a></h3>
<p>The Jacobian relates joint velocities to end-effector velocities:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ẋ = J(θ) * θ̇</span><br></span></code></pre></div></div>
<p>Where J(θ) is the Jacobian matrix and θ̇ is the vector of joint velocities.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="334-dynamics-equations">3.3.4 Dynamics Equations<a href="#334-dynamics-equations" class="hash-link" aria-label="Direct link to 3.3.4 Dynamics Equations" title="Direct link to 3.3.4 Dynamics Equations" translate="no">​</a></h3>
<p>Robot dynamics are described by the Lagrange-Euler equations or Newton-Euler formulation. For a manipulator:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">M(q)q̈ + C(q, q̇)q̇ + G(q) = τ</span><br></span></code></pre></div></div>
<p>Where:</p>
<ul>
<li class="">M(q): Mass/inertia matrix</li>
<li class="">C(q, q̇): Coriolis and centrifugal terms</li>
<li class="">G(q): Gravity terms</li>
<li class="">τ: Joint torques</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="34-control-theory-mathematics">3.4 Control Theory Mathematics<a href="#34-control-theory-mathematics" class="hash-link" aria-label="Direct link to 3.4 Control Theory Mathematics" title="Direct link to 3.4 Control Theory Mathematics" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="341-state-space-representation">3.4.1 State Space Representation<a href="#341-state-space-representation" class="hash-link" aria-label="Direct link to 3.4.1 State Space Representation" title="Direct link to 3.4.1 State Space Representation" translate="no">​</a></h3>
<p>A system can be represented in state space form as:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ẋ(t) = f(x(t), u(t), t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">y(t) = g(x(t), u(t), t)</span><br></span></code></pre></div></div>
<p>Where x is the state vector, u is the input vector, and y is the output vector.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="342-linear-time-invariant-systems">3.4.2 Linear Time-Invariant Systems<a href="#342-linear-time-invariant-systems" class="hash-link" aria-label="Direct link to 3.4.2 Linear Time-Invariant Systems" title="Direct link to 3.4.2 Linear Time-Invariant Systems" translate="no">​</a></h3>
<p>For linear time-invariant (LTI) systems:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ẋ = Ax + Bu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">y = Cx + Du</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="343-stability-analysis">3.4.3 Stability Analysis<a href="#343-stability-analysis" class="hash-link" aria-label="Direct link to 3.4.3 Stability Analysis" title="Direct link to 3.4.3 Stability Analysis" translate="no">​</a></h3>
<p>Lyapunov stability theory provides methods for analyzing system stability. A system is stable if for any ε &gt; 0, there exists δ &gt; 0 such that ||x(0)|| &lt; δ implies ||x(t)|| &lt; ε for all t ≥ 0.</p>
<p>For linear systems, stability is determined by the eigenvalues of the A matrix: all eigenvalues must have negative real parts.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="344-controllability-and-observability">3.4.4 Controllability and Observability<a href="#344-controllability-and-observability" class="hash-link" aria-label="Direct link to 3.4.4 Controllability and Observability" title="Direct link to 3.4.4 Controllability and Observability" translate="no">​</a></h3>
<p>A system is controllable if it&#x27;s possible to drive the state from any initial state to any final state in finite time. It&#x27;s observable if the state can be determined from the output measurements.</p>
<p>Controllability matrix: C = [B, AB, A²B, ..., A^(n-1)B]
Observability matrix: O = [C, CA, CA², ..., CA^(n-1)]^T</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="35-optimization-in-physical-ai">3.5 Optimization in Physical AI<a href="#35-optimization-in-physical-ai" class="hash-link" aria-label="Direct link to 3.5 Optimization in Physical AI" title="Direct link to 3.5 Optimization in Physical AI" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="351-gradient-based-optimization">3.5.1 Gradient-Based Optimization<a href="#351-gradient-based-optimization" class="hash-link" aria-label="Direct link to 3.5.1 Gradient-Based Optimization" title="Direct link to 3.5.1 Gradient-Based Optimization" translate="no">​</a></h3>
<p>Many robotics problems can be formulated as optimization problems. For minimizing a cost function J(θ):</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">θ_{k+1} = θ_k - α∇J(θ_k)</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="352-linear-quadratic-regulator-lqr">3.5.2 Linear Quadratic Regulator (LQR)<a href="#352-linear-quadratic-regulator-lqr" class="hash-link" aria-label="Direct link to 3.5.2 Linear Quadratic Regulator (LQR)" title="Direct link to 3.5.2 Linear Quadratic Regulator (LQR)" translate="no">​</a></h3>
<p>The LQR finds optimal control for linear systems with quadratic cost:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">J = ∫[x^TQx + u^TRu]dt</span><br></span></code></pre></div></div>
<p>The optimal control law is: u = -Kx, where K is computed from the algebraic Riccati equation.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="353-trajectory-optimization">3.5.3 Trajectory Optimization<a href="#353-trajectory-optimization" class="hash-link" aria-label="Direct link to 3.5.3 Trajectory Optimization" title="Direct link to 3.5.3 Trajectory Optimization" translate="no">​</a></h3>
<p>Trajectory optimization finds optimal state and control trajectories that minimize a cost function while satisfying constraints.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="36-uncertainty-and-estimation">3.6 Uncertainty and Estimation<a href="#36-uncertainty-and-estimation" class="hash-link" aria-label="Direct link to 3.6 Uncertainty and Estimation" title="Direct link to 3.6 Uncertainty and Estimation" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="361-state-estimation">3.6.1 State Estimation<a href="#361-state-estimation" class="hash-link" aria-label="Direct link to 3.6.1 State Estimation" title="Direct link to 3.6.1 State Estimation" translate="no">​</a></h3>
<p>Kalman filters are commonly used for state estimation in robotic systems with noisy sensors. The discrete-time Kalman filter equations are:</p>
<p><strong>Prediction:</strong></p>
<ul>
<li class="">x̂_k|k-1 = F_k * x̂_k-1|k-1 + B_k * u_k</li>
<li class="">P_k|k-1 = F_k * P_k-1|k-1 * F_k^T + Q_k</li>
</ul>
<p><strong>Update:</strong></p>
<ul>
<li class="">K_k = P_k|k-1 * H_k^T * (H_k * P_k|k-1 * H_k^T + R_k)^(-1)</li>
<li class="">x̂_k|k = x̂_k|k-1 + K_k * (z_k - H_k * x̂_k|k-1)</li>
<li class="">P_k|k = (I - K_k * H_k) * P_k|k-1</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="362-probability-in-robotics">3.6.2 Probability in Robotics<a href="#362-probability-in-robotics" class="hash-link" aria-label="Direct link to 3.6.2 Probability in Robotics" title="Direct link to 3.6.2 Probability in Robotics" translate="no">​</a></h3>
<p>Bayesian inference is fundamental to many robotics algorithms:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">P(A|B) = P(B|A) * P(A) / P(B)</span><br></span></code></pre></div></div>
<p>This forms the basis of algorithms like the Bayes filter, which underlies the Kalman filter and particle filters.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="37-mathematical-modeling-of-humanoid-systems">3.7 Mathematical Modeling of Humanoid Systems<a href="#37-mathematical-modeling-of-humanoid-systems" class="hash-link" aria-label="Direct link to 3.7 Mathematical Modeling of Humanoid Systems" title="Direct link to 3.7 Mathematical Modeling of Humanoid Systems" translate="no">​</a></h2>
<p>Humanoid robots present unique mathematical challenges due to their high degrees of freedom and balance requirements.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="371-zero-moment-point-zmp">3.7.1 Zero Moment Point (ZMP)<a href="#371-zero-moment-point-zmp" class="hash-link" aria-label="Direct link to 3.7.1 Zero Moment Point (ZMP)" title="Direct link to 3.7.1 Zero Moment Point (ZMP)" translate="no">​</a></h3>
<p>The ZMP is a critical concept for bipedal locomotion stability. It&#x27;s the point on the ground where the net moment of the ground reaction force is zero:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">x_zmp = (Σ(m_i * g * x_i - m_i * ẍ_i)) / (Σ(m_i * g))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">y_zmp = (Σ(m_i * g * y_i - m_i * ÿ_i)) / (Σ(m_i * g))</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="372-linear-inverted-pendulum-model-lipm">3.7.2 Linear Inverted Pendulum Model (LIPM)<a href="#372-linear-inverted-pendulum-model-lipm" class="hash-link" aria-label="Direct link to 3.7.2 Linear Inverted Pendulum Model (LIPM)" title="Direct link to 3.7.2 Linear Inverted Pendulum Model (LIPM)" translate="no">​</a></h3>
<p>The LIPM simplifies humanoid balance to a point mass at height h:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ẍ = g/h * (x - x_zmp)</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="38-practical-implementation-tips">3.8 Practical Implementation Tips<a href="#38-practical-implementation-tips" class="hash-link" aria-label="Direct link to 3.8 Practical Implementation Tips" title="Direct link to 3.8 Practical Implementation Tips" translate="no">​</a></h2>
<p>When implementing mathematical models in code:</p>
<ol>
<li class=""><strong>Numerical Stability</strong>: Choose algorithms that are numerically stable</li>
<li class=""><strong>Computational Efficiency</strong>: Optimize for real-time performance where needed</li>
<li class=""><strong>Coordinate Frame Consistency</strong>: Maintain consistent coordinate frame definitions</li>
<li class=""><strong>Unit Consistency</strong>: Always verify units in equations and code</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="chapter-summary">Chapter Summary<a href="#chapter-summary" class="hash-link" aria-label="Direct link to Chapter Summary" title="Direct link to Chapter Summary" translate="no">​</a></h2>
<p>This chapter provided the mathematical foundations necessary for Physical AI and robotics. We covered linear algebra, kinematics and dynamics, control theory mathematics, optimization methods, and uncertainty handling. The mathematics of humanoid systems was also discussed, particularly concepts like ZMP and LIPM that are essential for bipedal locomotion.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="key-terms">Key Terms<a href="#key-terms" class="hash-link" aria-label="Direct link to Key Terms" title="Direct link to Key Terms" translate="no">​</a></h2>
<ul>
<li class="">Homogeneous Transformations</li>
<li class="">Jacobian Matrix</li>
<li class="">Lyapunov Stability</li>
<li class="">Kalman Filter</li>
<li class="">Zero Moment Point (ZMP)</li>
<li class="">Linear Inverted Pendulum Model (LIPM)</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="exercises">Exercises<a href="#exercises" class="hash-link" aria-label="Direct link to Exercises" title="Direct link to Exercises" translate="no">​</a></h2>
<ol>
<li class="">Implement forward and inverse kinematics for a 3-DOF planar manipulator</li>
<li class="">Simulate a simple control system and analyze its stability</li>
<li class="">Implement a basic Kalman filter and test it with noisy measurements</li>
<li class="">Calculate ZMP for a simple humanoid model</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="references">References<a href="#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References" translate="no">​</a></h2>
<ul>
<li class="">Craig, J. J. (2005). Introduction to Robotics: Mechanics and Control.</li>
<li class="">Spong, M. W., Hutchinson, S., &amp; Vidyasagar, M. (2006). Robot Modeling and Control.</li>
<li class="">Siciliano, B., &amp; Khatib, O. (2016). Springer Handbook of Robotics.</li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/RizSheik/humanoid-robotics-course/edit/main/docs/module-1-physical-ai-foundations/chapter-3.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#learning-objectives" class="table-of-contents__link toc-highlight">Learning Objectives</a></li><li><a href="#31-mathematical-tools-for-physical-ai" class="table-of-contents__link toc-highlight">3.1 Mathematical Tools for Physical AI</a></li><li><a href="#32-linear-algebra-in-robotics" class="table-of-contents__link toc-highlight">3.2 Linear Algebra in Robotics</a><ul><li><a href="#321-vector-spaces-and-transformations" class="table-of-contents__link toc-highlight">3.2.1 Vector Spaces and Transformations</a></li><li><a href="#322-rotation-matrices" class="table-of-contents__link toc-highlight">3.2.2 Rotation Matrices</a></li><li><a href="#323-homogeneous-transformations" class="table-of-contents__link toc-highlight">3.2.3 Homogeneous Transformations</a></li></ul></li><li><a href="#33-kinematics-and-dynamics" class="table-of-contents__link toc-highlight">3.3 Kinematics and Dynamics</a><ul><li><a href="#331-forward-kinematics" class="table-of-contents__link toc-highlight">3.3.1 Forward Kinematics</a></li><li><a href="#332-inverse-kinematics" class="table-of-contents__link toc-highlight">3.3.2 Inverse Kinematics</a></li><li><a href="#333-jacobian-matrix" class="table-of-contents__link toc-highlight">3.3.3 Jacobian Matrix</a></li><li><a href="#334-dynamics-equations" class="table-of-contents__link toc-highlight">3.3.4 Dynamics Equations</a></li></ul></li><li><a href="#34-control-theory-mathematics" class="table-of-contents__link toc-highlight">3.4 Control Theory Mathematics</a><ul><li><a href="#341-state-space-representation" class="table-of-contents__link toc-highlight">3.4.1 State Space Representation</a></li><li><a href="#342-linear-time-invariant-systems" class="table-of-contents__link toc-highlight">3.4.2 Linear Time-Invariant Systems</a></li><li><a href="#343-stability-analysis" class="table-of-contents__link toc-highlight">3.4.3 Stability Analysis</a></li><li><a href="#344-controllability-and-observability" class="table-of-contents__link toc-highlight">3.4.4 Controllability and Observability</a></li></ul></li><li><a href="#35-optimization-in-physical-ai" class="table-of-contents__link toc-highlight">3.5 Optimization in Physical AI</a><ul><li><a href="#351-gradient-based-optimization" class="table-of-contents__link toc-highlight">3.5.1 Gradient-Based Optimization</a></li><li><a href="#352-linear-quadratic-regulator-lqr" class="table-of-contents__link toc-highlight">3.5.2 Linear Quadratic Regulator (LQR)</a></li><li><a href="#353-trajectory-optimization" class="table-of-contents__link toc-highlight">3.5.3 Trajectory Optimization</a></li></ul></li><li><a href="#36-uncertainty-and-estimation" class="table-of-contents__link toc-highlight">3.6 Uncertainty and Estimation</a><ul><li><a href="#361-state-estimation" class="table-of-contents__link toc-highlight">3.6.1 State Estimation</a></li><li><a href="#362-probability-in-robotics" class="table-of-contents__link toc-highlight">3.6.2 Probability in Robotics</a></li></ul></li><li><a href="#37-mathematical-modeling-of-humanoid-systems" class="table-of-contents__link toc-highlight">3.7 Mathematical Modeling of Humanoid Systems</a><ul><li><a href="#371-zero-moment-point-zmp" class="table-of-contents__link toc-highlight">3.7.1 Zero Moment Point (ZMP)</a></li><li><a href="#372-linear-inverted-pendulum-model-lipm" class="table-of-contents__link toc-highlight">3.7.2 Linear Inverted Pendulum Model (LIPM)</a></li></ul></li><li><a href="#38-practical-implementation-tips" class="table-of-contents__link toc-highlight">3.8 Practical Implementation Tips</a></li><li><a href="#chapter-summary" class="table-of-contents__link toc-highlight">Chapter Summary</a></li><li><a href="#key-terms" class="table-of-contents__link toc-highlight">Key Terms</a></li><li><a href="#exercises" class="table-of-contents__link toc-highlight">Exercises</a></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Textbook</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/humanoid-robotics-course/docs/module-1-the-robotic-nervous-system/module-1-intro">Module 1 – The Robotic Nervous System</a></li><li class="footer__item"><a class="footer__link-item" href="/humanoid-robotics-course/docs/module-2-the-digital-twin/module-2-intro">Module 2 – The Digital Twin</a></li><li class="footer__item"><a class="footer__link-item" href="/humanoid-robotics-course/docs/module-3-the-ai-robot-brain/module-3-intro">Module 3 – The AI-Robot Brain</a></li><li class="footer__item"><a class="footer__link-item" href="/humanoid-robotics-course/docs/module-4-vision-language-action-systems/module-4-intro">Module 4 – Vision-Language-Action Systems</a></li><li class="footer__item"><a class="footer__link-item" href="/humanoid-robotics-course/docs/capstone-the-autonomous-humanoid/capstone-overview">Capstone: The Autonomous Humanoid</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Resources</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/humanoid-robotics-course/docs/appendices/hardware-requirements">Appendices</a></li><li class="footer__item"><a href="https://github.com/RizSheik/humanoid-robotics-course" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Physical AI & Humanoid Robotics — AI Systems in the Physical World. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>